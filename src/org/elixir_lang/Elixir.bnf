{
  parserClass="org.elixir_lang.parser.ElixirParser"
  parserImports=[
    "static org.elixir_lang.Level.*"
    "static org.elixir_lang.parser.ExternalRules.*"
    "static org.elixir_lang.parser.ExternalRules.Operator.*"
  ]

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  // direct children of matchedExpression
  extends("matched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=matchedExpression
  // direct children of unmatchedExpression
  extends("unmatched(AccessExpression|.*Operation|((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)Call|Qualified(Alias|MultipleAliases))")=unmatchedExpression

  // name identifier owner calls - no argument calls are included because in a pipeline they can have effective arguments
  elementTypeFactory("((un)?matched((((At)?Unq)|Q)ualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")="org.elixir_lang.ElementTypeFactory.factory"
  methods(           "((un)?matched((At)?Unqualified(No)?(Argument|Parenthese)s|Dot)|unqualifiedNoParenthesesManyArguments)Call")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    isCalling
    isCallingMacro
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // qualified calls that need to implement #qualifier()
  methods("(un)?matchedQualified(No)?(Argument|Parenthese)sCall")=[
    canonicalName
    canonicalNameSet
    functionName
    functionNameElement
    getDoBlock
    hasDoBlockOrKeyword
    getName
    getNameIdentifier
    getPresentation
    getReference
    getStub
    getUseScope
    isCalling
    isCallingMacro
    moduleName
    primaryArguments
    primaryArity
    processDeclarations
    qualifier
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    secondaryArguments
    secondaryArity
    setName
  ]

  // in operations that works as calls
  implements("(un)?matchedInOperation")=[
    "org.elixir_lang.psi.call.Call"
    "org.elixir_lang.psi.operation.In"
  ]
  // methods set by infix operations below

  // `not in` operations that works as calls
  implements("(un)?matchedNotInOperation")=[
    "org.elixir_lang.psi.call.Call"
    "org.elixir_lang.psi.operation.NotIn"
  ]
  methods("(un)?matchedNotInOperation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    leftOperand
    moduleName
    operator
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    rightOperand
    secondaryArguments
    secondaryArity
    setName
  ]

  /* infix operations that work as name identifier owner calls - specifically support getNameIdentifier so they can
     return their operator, so it is easy to use a different operator when making customer operators like in Bitwise or
     the free arrow operators */
  implements(        "(un)?matched(Comparison|Relational)Operation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Infix"
  ]
  methods(           "(un)?matched(Addition|And|Arrow|Comparison|In|InMatch|Match|Multiplication|Or|Pipe|Relational|Three|Two|Type|When)Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    leftOperand
    moduleName
    operator
    primaryArguments
    primaryArity
    processDeclarations
    quote
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    rightOperand
    secondaryArguments
    secondaryArity
    setName
  ]

  implements("(un)?matchedAdditionOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Addition"
  ]
  // methods set by infix operations above

  implements("(un)?matchedAndOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.And"
  ]
  // methods set by infix operations above

  implements("(un)?matchedArrowOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Arrow"
  ]

  implements("(un)?matchedInMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.InMatch"
  ]
  // methods set by infix operations above

  implements("(un)?matchedMatchOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Match"
  ]
  // methods set by infix operations above

  implements("(un)?matchedMultiplicationOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Multiplication"
  ]
  // methods set by infix operations above

  implements("(un)?matchedOrOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Or"
  ]
  // methods set by infix operations above

  implements("(un)?matchedPipeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Pipe"
  ]
  // methods set by infix operations above

  implements("(un)?matchedThreeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Three"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTwoOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Two"
  ]
  // methods set by infix operations above

  implements("(un)?matchedTypeOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Type"
  ]
  // methods set by infix operations above

  implements("(un)?matchedWhenOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.When"
  ]
  // methods set by infix operations above

  /*
   * Prefix operations
   *
   * Have names (their operators), but aren't stubbed because they don't define structures.
   */
  implements(        "(at|capture|unary)NumericOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.Prefix"
  ]
  methods(           "((at|capture|unary)Numeric|(un)?matched(UnaryNonNumeric|Unary))Operation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    moduleName
    operand
    operator
    primaryArguments
    primaryArity
    quote
    secondaryArguments
    secondaryArity
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    setName
  ]

  // atNonNumeric operations
  implements("(un)?matchedAt(NonNumeric)?Operation")=[
    "org.elixir_lang.psi.AtNonNumericOperation"
  ]
  methods("(un)?matchedAt(NonNumeric)?Operation")=[
    getReference
    moduleAttributeName
    operand
    operator
    quote
  ]

  // captureNonNumeric operations
  implements(        "(un)?matched.*CaptureNonNumericOperation")=[
    "org.elixir_lang.psi.call.Named"
    "org.elixir_lang.psi.operation.capture.NonNumeric"
  ]
  methods(           "(un)?matched.*CaptureNonNumericOperation")=[
    functionName
    functionNameElement
    getDoBlock
    getName
    getNameIdentifier
    getReference
    hasDoBlockOrKeyword
    isCalling
    isCallingMacro
    moduleName
    operand
    operator
    primaryArguments
    primaryArity
    quote
    secondaryArguments
    secondaryArity
    resolvedFinalArity
    resolvedFinalArityRange
    resolvedModuleName
    resolvedPrimaryArity
    resolvedSecondaryArity
    setName
  ]

  // unaryNonNumeric operations
  implements("(un)?matchedUnary(NonNumeric)?Operation")=[
    "org.elixir_lang.psi.UnaryNonNumericOperation"
  ]
  // method set by prefix operations above

  // QualifiedBracketOperation
  implements("(un)?matchedQualifiedBracketOperation")=[
    "org.elixir_lang.psi.QualifiedBracketOperation"
  ]
  methods(   "(un)?matchedQualifiedBracketOperation")=[
    qualifier
    quote
  ]

  // QualifiedMultipleAliases
  implements("(un)?matchedQualifiedMultipleAliases")=[
    "org.elixir_lang.psi.QualifiedMultipleAliases"
  ]
  methods(   "(un)?matchedQualifiedMultipleAliases")=[
    quote
  ]

  // Heredoc
  methods("(charList|string)Heredoc")=[
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
  ]

  // Quote
  methods("(charList|string)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    quote
    quoteAsAtom
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
  ]

  // Sigil Heredoc
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Heredoc") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getFragmentType
    getHeredocLineList
    indentation
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
    sigilDelimiter
    sigilName
  ]

  // Sigil Line
  methods("(interpolated|literal)((CharList|String)Sigil|Regex|Sigil|Words)Line") = [
    addEscapedCharacterCodePoints
    addEscapedEOL
    addFragmentCodePoints
    addHexadecimalEscapeSequenceCodePoints
    getBody
    getFragmentType
    indentation
    quote
    quoteBinary
    quoteEmpty
    quoteInterpolation
    quoteLiteral
    sigilDelimiter
    sigilName
    terminator
  ]

  psiClassPrefix="Elixir"
  psiImplClassSuffix="Impl"
  psiPackage="org.elixir_lang.psi"
  psiImplPackage="org.elixir_lang.psi.impl"
  psiImplUtilClass="org.elixir_lang.psi.impl.ElixirPsiImplUtil"

  elementTypeHolderClass="org.elixir_lang.psi.ElixirTypes"
  elementTypeClass="org.elixir_lang.psi.ElixirElementType"
  tokenTypeClass="org.elixir_lang.psi.ElixirTokenType"

  tokens = [
    ADDITION_OPERATOR = "+"
    AFTER = "after"
    ALIAS_TOKEN = "Alias"
    AND_SYMBOL_OPERATOR = "&&&, &&"
    AND_WORD_OPERATOR = "`and`"
    ARROW_OPERATOR = "<<<, <<~, <|>, <~>, >>>, ~>>, <~, |>, ~>"
    ASSOCIATION_OPERATOR = "=>"
    ATOM_FRAGMENT = "A-Z, a-z, _, @, 0-9. ?, !"
    AT_OPERATOR = "@"
    BASE_WHOLE_NUMBER_PREFIX = "0"
    BINARY_WHOLE_NUMBER_BASE = "b"
    BIT_STRING_OPERATOR = "<<>>"
    CALL = "<zero-width-call>"
    CAPTURE_OPERATOR = "&"
    CATCH = "catch"
    CHAR_LIST_FRAGMENT = "Char List Fragment"
    CHAR_LIST_HEREDOC_PROMOTER = "Char List Heredoc Promoter (''')"
    CHAR_LIST_HEREDOC_TERMINATOR = "Char List Heredoc Terminator (''')"
    CHAR_LIST_PROMOTER = "Char List Promoter (')"
    CHAR_LIST_SIGIL_HEREDOC_PROMOTER = "Char List Sigil Heredoc Promoter (\"\"\", ''')"
    CHAR_LIST_SIGIL_HEREDOC_TERMINATOR = "Char List Sigil Heredoc Terminator (\"\"\", ''')"
    CHAR_LIST_SIGIL_PROMOTER = "Char List Sigil Promoter ({, [, <, \", /, (, |, ')"
    CHAR_LIST_SIGIL_TERMINATOR = "Char List Sigil Terminator (}, ], >, \", /, ), |, ')"
    CHAR_LIST_TERMINATOR = "Char List Terminator (')"
    CHAR_TOKENIZER = "?"
    CLOSING_BIT = ">>"
    CLOSING_BRACKET = "]"
    CLOSING_CURLY = "}"
    // TODO remove once CLOSING_PARENTHESIS is used in emptyParentheses rule
    CLOSING_PARENTHESIS = ")"
    COLON = ":"
    COMMA = ","
    COMMENT = "#"
    COMPARISON_OPERATOR = "!==, ===, !=, ==, =~"
    DECIMAL_MARK = "Decimal Mark (.)"
    DIVISION_OPERATOR = "/"
    DO = "do"
    DOT_OPERATOR = "."
    EEX_CLOSING = "%>"
    EEX_COMMENT = "EEx Comment"
    EEX_COMMENT_MARKER = "EEx Comment Marker (#)"
    EEX_DATA = "EEx Data"
    EEX_EMPTY_MARKER = "EEx Empty Marker"
    EEX_EQUALS_MARKER = "EEx Equals Marker (=)"
    EEX_ESCAPED_OPENING = "<%%"
    EEX_FORWARD_SLASH_MARKER = "EEx Forward Slash Marker (/)"
    EEX_OPENING = "<%"
    EEX_PIPE_MARKER = "EEx Pipe Marker (|)"
    ELSE = "else"
    EOL = "\\n, \\r\\n"
    END = "end"
    ESCAPE = "\\"
    ESCAPED_CHARACTER_TOKEN = "\\<character>, \\x{<hexadecimal-digit>}, \\x<hexadecimal-digit>, \\\\n, \\\\r\\n"
    EXPONENT_MARK = "E, e"
    FALSE = "false"
    FN = "fn"
    HEREDOC_LINE_WHITE_SPACE_TOKEN = "Whitespace at beginning of line of heredoc"
    HEREDOC_PREFIX_WHITE_SPACE = "Whitespace at beginning of last line of heredoc before terminator"
    HEXADECIMAL_WHOLE_NUMBER_BASE = "x"
    IDENTIFIER_TOKEN = "identifier"
    INTERPOLATING_CHAR_LIST_SIGIL_NAME = "c"
    INTERPOLATING_REGEX_SIGIL_NAME = "r"
    INTERPOLATING_SIGIL_NAME = "a-b, d-q, t-v, x-z"
    INTERPOLATING_STRING_SIGIL_NAME = "s"
    INTERPOLATING_WORDS_SIGIL_NAME = "w"
    // Can't be just "}", because that's used for the more general CLOSING_CURLY
    INTERPOLATION_END = "Interpolation End (})"
    // Human-readable "Interpolation Start" to match format of INTERPOLATION_END
    INTERPOLATION_START = "Interpolation Start (#{)"
    INVALID_BINARY_DIGITS = "A-Z, a-z, 2-9"
    INVALID_DECIMAL_DIGITS = "A-Z, a-z"
    INVALID_HEXADECIMAL_DIGITS = "G-Z, g-z"
    INVALID_OCTAL_DIGITS = "A-Z, a-z, 8-9"
    INVALID_UNKNOWN_BASE_DIGITS = "A-Z, a-z, 0-9"
    IN_MATCH_OPERATOR = "<-, \\\\"
    IN_OPERATOR = "in"
    KEYWORD_PAIR_COLON = "Keyword Pair Colon (:)"
    LITERAL_CHAR_LIST_SIGIL_NAME = "C"
    LITERAL_REGEX_SIGIL_NAME = "R"
    LITERAL_SIGIL_NAME = "A-B, D-Q, T-V, X-Z"
    LITERAL_STRING_SIGIL_NAME = "S"
    LITERAL_WORDS_SIGIL_NAME = "W"
    MAP_OPERATOR = "%{}"
    MATCH_OPERATOR = "="
    MINUS_OPERATOR = "-"
    MULTIPLICATION_OPERATOR = "*"
    NEGATE_OPERATOR = "-"
    NIL = "nil"
    NOT_OPERATOR = "not"
    NUMBER_SEPARATOR = "_"
    NUMBER_OR_BADARITH_OPERATOR = "+"
    OBSOLETE_BINARY_WHOLE_NUMBER_BASE = "B"
    OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE = "X"
    OCTAL_WHOLE_NUMBER_BASE = "o"
    OPENING_BIT = "<<"
    OPENING_BRACKET = "["
    OPENING_CURLY = "{"
    OPENING_PARENTHESIS = "("
    OR_SYMBOL_OPERATOR = "|||, ||"
    OR_WORD_OPERATOR = "`or`"
    PIPE_OPERATOR = "|"
    PLUS_OPERATOR = "+"
    RANGE_OPERATOR = ".."
    REGEX_FRAGMENT = "Regex Fragment"
    REGEX_HEREDOC_PROMOTER = "Regex Heredoc Promoter (\"\"\", ''')"
    REGEX_HEREDOC_TERMINATOR = "Regex Heredoc Terminator (\"\"\", ''')"
    REGEX_PROMOTER = "Regex Promoter ({, [, <, \", /, (, |, ')"
    REGEX_TERMINATOR = "Regex Terminator ({, [, <, \", /, (, |, ')"
    RELATIONAL_OPERATOR = "<, <=, >=, >"
    RESCUE = "rescue"
    // TOO remove once SEMICOLON is used in endOfExpression rule
    SEMICOLON = ";"
    SIGIL_FRAGMENT = "Sigil Fragment"
    SIGIL_HEREDOC_PROMOTER = "Sigil Heredoc Promoter (\"\"\", ''')"
    SIGIL_HEREDOC_TERMINATOR = "Sigil Heredoc Terminator (\"\"\", ''')"
    SIGIL_MODIFIER = "Sigil Modifier (A-Z, a-z)"
    SIGIL_PROMOTER = "Sigil Promoter ({, [, <, \", /, (, |, ')"
    SIGIL_TERMINATOR = "Sigil Terminator ({, [, <, \", /, (, |, ')"
    SIGN_OPERATOR = "Sign Operator (+, -)"
    STAB_OPERATOR = "->"
    STRING_FRAGMENT = "String Fragment"
    STRING_HEREDOC_PROMOTER = "String Heredoc Promoter (\"\"\")"
    STRING_HEREDOC_TERMINATOR = "String Heredoc Terminator (\"\"\")"
    STRING_PROMOTER = "String Promoter (\")"
    STRING_SIGIL_HEREDOC_PROMOTER = "String Sigil Heredoc Promoter (\"\"\", ''')"
    STRING_SIGIL_HEREDOC_TERMINATOR = "String Sigil Heredoc Terminator (\"\"\", ''')"
    STRING_SIGIL_PROMOTER = "String Sigil Promoter ({, [, <, \", /, (, |, ')"
    STRING_SIGIL_TERMINATOR = "String Sigil Terminator ({, [, <, \", /, (, |, ')"
    STRING_TERMINATOR = "String Terminator (\")"
    // TODO remove once containers are available for `{}` after alias for empty structs
    STRUCT_OPERATOR = "%"
    SUBTRACTION_OPERATOR = "-"
    TILDE = "~"
    TRUE = "true"
    TUPLE_OPERATOR = "{}"
    TWO_OPERATOR = "++, --, <>"
    // https://github.com/elixir-lang/elixir/commit/3487d00ddb5e90c7cf0e65d03717903b9b27eafd
    THREE_OPERATOR = "^^^"
    TYPE_OPERATOR = "::"
    UNARY_OPERATOR = "~~~, !, ^"
    UNICODE_ESCAPE_CHARACTER = "u"
    UNKNOWN_WHOLE_NUMBER_BASE = "A-Z, a, c-n, p-w, z"
    VALID_BINARY_DIGITS = "0-1"
    VALID_DECIMAL_DIGITS = "0-9"
    VALID_HEXADECIMAL_DIGITS = "A-F, a-f, 0-9"
    VALID_OCTAL_DIGITS = "0-7"
    WHEN_OPERATOR = "when"
    WORDS_FRAGMENT = "Words Fragment"
    WORDS_HEREDOC_PROMOTER = "Words Heredoc Promoter (\"\"\", ''')"
    WORDS_HEREDOC_TERMINATOR = "Words Heredoc Terminator (\"\"\", ''')"
    WORDS_PROMOTER = "Words Promoter ({, [, <, \", /, (, |, ')"
    WORDS_TERMINATOR = "Words Terminator ({, [, <, \", /, (, |, ')"
  ]
}

// `elixirFile` has more error recovery, so it'll match almost anything, so it needs to be after `eex`
private eexOrElixirFile ::= eex | elixirFile

// expressionList is optional to handle code-less file that contains only EOL between blank lines and order comment
// lines
private elixirFile ::= endOfExpressionMaybe (expressionList endOfExpressionMaybe)?

/*
 *
 *
 * Expression List
 *
 *
 */

private eolStar ::= EOL*
// Must have at least one EOL or SEMICOLON, but at most one SEMICOLON
endOfExpression ::= SEMICOLON | EOL+ { implements = "org.elixir_lang.psi.Unquoted" }
private endOfExpressionMaybe ::= endOfExpression?

/*
 *
 * Expression
 *
 */

private expression ::= emptyParentheses |
                       unmatchedExpression |
                       unqualifiedNoParenthesesManyArgumentsCall
                       { recoverWhile = expressionRecoverWhile }
// EOL and SEMICOLON for endOfExpression
/* INTERPOLATION_END because interpolation(elixirFile(expression)) needs expression to stop of on INTERPOLATION_END for
   interpolation */
// END for stabBody's usage of expression
// CLOSING_* because they are endings to subexpressions
// STAB_OPERATOR because it ends when clause for no parentheses stab guard clauses
// blockIdentifier for one-liner blockItems where there isn't a newline between block expressions and following blockIdentifier.
private expressionRecoverUntil ::= EOL | CLOSING_BIT | CLOSING_BRACKET | CLOSING_CURLY | CLOSING_PARENTHESIS | COMMA | INTERPOLATION_END | SEMICOLON | STAB_OPERATOR | END | blockIdentifier | EEX_CLOSING
private expressionRecoverWhile ::= !expressionRecoverUntil

private expressionList ::= expression (endOfExpression expression)*

/*
 *
 *
 * Function Calls
 *
 *
 */

/*
 *
 * No Parentheses
 *
 */

/*
 * Many Arguments
 */

/* Have to prevent matchedExpression that is actually a keywordKey from being parsed as just a matchedExpression or
   callArgumentsNoParenthesesCommaExpression COMMA EOL* callArgumentsNoParenthesesKeywords will never match. */
private noParenthesesExpression ::= emptyParentheses |
                                    /* Must be before matchedExpression because noParenthesesExpression is
                                       `matchedExpressionDotIdentifier callArgumentsNoParenthesesManyStrict` which is
                                       longer than `matchedExpressionDotIdentifier` in matchedExpression. */
                                    /* This will be marked as an error by
                                       {@link org.elixir_lang.inspection.NoParenthesesManyStrict} */
                                    noParenthesesManyStrictNoParenthesesExpression |
                                    matchedExpression
/* Special class for wrapping noParenthesesCall so that
   {@link: org.elixir_lang.inspection.NoParenthesesManyStrict} can just search for
   ElixirNoParenthesesManyStrictNoParenthesesExpression isn't of having to differentiate between valid and invalid
   ElixirNoParenthesesCall. */
noParenthesesManyStrictNoParenthesesExpression ::= unqualifiedNoParenthesesManyArgumentsCall
                                                   { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
/* Special class for wrapping rules so that
   {@link: org.elixir_lang.inspection.NoParenthesesStrict} can just search for
   ElixirNoParenthesesStrict instead of having to differentiate between valid and invalid
   rule classes. */
noParenthesesStrict ::= emptyParentheses |
                        OPENING_PARENTHESIS (
                                             noParenthesesKeywords |
                                             noParenthesesManyArguments
                                            ) CLOSING_PARENTHESIS
                        {
                          implements = [
                            "org.elixir_lang.psi.Arguments"
                            "org.elixir_lang.psi.QuotableArguments"
                          ]
                          methods = [
                            arguments
                            quoteArguments
                          ]
                        }

/* 1. (positional, keywords)
   2. (positional, positional)
   3. (positional, positional, keywords) */
private noParenthesesManyArguments ::= matchedExpression infixComma noParenthesesKeywords |
                                       matchedExpression (infixComma noParenthesesExpression)+ (infixComma noParenthesesKeywords)?
private noParenthesesManyArgumentsStrict ::= noParenthesesManyArguments |
                                             noParenthesesStrict

// A rule instead of a token so that there is a PsiElement to return from getNameIdentifier
identifier ::= IDENTIFIER_TOKEN
               {
                 implements = "org.elixir_lang.psi.Quotable"
                 methods = [
                   getPresentation
                   getReference
                   quote
                 ]
               }

private notKeywordPairColon ::= !KEYWORD_PAIR_COLON
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125
unqualifiedNoParenthesesManyArgumentsCall ::= identifier notKeywordPairColon
                                              noParenthesesManyArgumentsStrict
                                              {
                                                implements = [
                                                  // MUST be first so visitElement is used in ElixirVisitor
                                                  "com.intellij.psi.PsiElement"
                                                  "org.elixir_lang.psi.call.StubBased<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                  "org.elixir_lang.psi.call.arguments.star.NoParentheses"
                                                  "org.elixir_lang.psi.qualification.Unqualified"
                                                  "org.elixir_lang.psi.Quotable"
                                                ]
                                                mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall>"
                                                stubClass = "org.elixir_lang.psi.stub.UnqualifiedNoParenthesesManyArgumentsCall"
                                              }

/*
 * 1+ Arguments
 */

noParenthesesKeywords ::= noParenthesesKeywordPair (infixComma noParenthesesKeywordPair)*
                          {
                            implements = "org.elixir_lang.psi.QuotableKeywordList"
                            methods = [
                              quotableKeywordPairList
                              quote
                            ]
                          }
noParenthesesKeywordPair ::= keywordKeyColon noParenthesesExpression
                             {
                               implements = "org.elixir_lang.psi.QuotableKeywordPair"
                               methods = [
                                 getKeywordKey
                                 getKeywordValue
                                 quote
                               ]
                             }

/*
 * 0 Arguments
 */

variable ::= IDENTIFIER_TOKEN notKeywordPairColon
             {
               implements = [
                 "org.elixir_lang.psi.NamedElement"
                 "org.elixir_lang.psi.Quotable"
               ]
               methods = [
                 getName
                 getNameIdentifier
                 quote
                 setName
               ]
             }

/*
 *
 *
 * Heredoc
 *
 *
 */

heredocLinePrefix ::= HEREDOC_LINE_WHITE_SPACE_TOKEN? { methods = [excessWhitespace] }
heredocPrefix ::= HEREDOC_PREFIX_WHITE_SPACE?

/*
 *
 * Quote Heredocs
 *
 */

/*
 * CharList Heredoc
 */

charListHeredoc ::= CHAR_LIST_HEREDOC_PROMOTER EOL
                    charListHeredocLine*
                    heredocPrefix CHAR_LIST_HEREDOC_TERMINATOR
                    {
                      implements = [
                        "org.elixir_lang.psi.Heredoc"
                        "org.elixir_lang.psi.InterpolatedCharList"
                        "org.elixir_lang.psi.Quote"
                      ]
                      pin = CHAR_LIST_HEREDOC_PROMOTER
                    }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
charListHeredocLine ::= heredocLinePrefix charListHeredocLineBody heredocLineEnd
                        {
                          implements = [
                            "org.elixir_lang.psi.HeredocLine"
                          ]
                          methods = [
                            getBody
                            quote
                          ]
                        }
charListHeredocLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | heredocEscapeSequence)*
                            { implements = "org.elixir_lang.psi.Body" }

/*
 * String Heredoc
 */

stringHeredoc ::= STRING_HEREDOC_PROMOTER EOL
                  stringHeredocLine*
                  heredocPrefix STRING_HEREDOC_TERMINATOR
                  {
                    implements = [
                      "org.elixir_lang.psi.Heredoc"
                      "org.elixir_lang.psi.InterpolatedString"
                    ]
                    pin = STRING_HEREDOC_PROMOTER
                  }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
stringHeredocLine ::= heredocLinePrefix stringHeredocLineBody heredocLineEnd
                      {
                        implements = [
                          "org.elixir_lang.psi.HeredocLine"
                        ]
                        methods = [
                          getBody
                          quote
                        ]
                      }
stringHeredocLineBody ::= (interpolation | STRING_FRAGMENT | heredocEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

/*
 *
 * Interpolated Sigil Heredocs
 *
 */

sigilModifiers ::= SIGIL_MODIFIER* { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

interpolatedCharListSigilHeredoc ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                     interpolatedCharListHeredocLine*
                                     heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                     {
                                       implements = [
                                         "org.elixir_lang.psi.CharListFragmented"
                                         "org.elixir_lang.psi.InterpolatedCharListHeredocLined"
                                         "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       ]
                                       pin = CHAR_LIST_SIGIL_HEREDOC_PROMOTER
                                     }
interpolatedCharListHeredocLine ::= heredocLinePrefix interpolatedCharListHeredocLineBody heredocLineEnd
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.HeredocLine"
                                      ]
                                      methods = [
                                        getBody
                                        quote
                                      ]
                                    }
interpolatedCharListHeredocLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | sigilHeredocEscapeSequence)*
                                        { implements = "org.elixir_lang.psi.Body" }

interpolatedRegexHeredoc ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                             interpolatedRegexHeredocLine*
                             heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.RegexFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = REGEX_HEREDOC_PROMOTER
                             }
interpolatedRegexHeredocLine ::= heredocLinePrefix interpolatedRegexHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedRegexHeredocLineBody ::= (interpolation | REGEX_FRAGMENT | sigilHeredocEscapeSequence)*
                          { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilHeredoc ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                             interpolatedSigilHeredocLine*
                             heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                 "org.elixir_lang.psi.SigilFragmented"
                               ]
                               pin = SIGIL_HEREDOC_PROMOTER
                             }
interpolatedSigilHeredocLine ::= heredocLinePrefix interpolatedSigilHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedSigilHeredocLineBody ::= (interpolation | SIGIL_FRAGMENT | sigilHeredocEscapeSequence)*
                                     { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilHeredoc ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                                   interpolatedStringHeredocLine*
                                   heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                   {
                                     implements = [
                                       "org.elixir_lang.psi.StringFragmented"
                                       "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                                       "org.elixir_lang.psi.InterpolatedStringHeredocLined"
                                     ]
                                     pin = STRING_SIGIL_HEREDOC_PROMOTER
                                   }
interpolatedStringHeredocLine ::= heredocLinePrefix interpolatedStringHeredocLineBody heredocLineEnd
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.HeredocLine"
                                    ]
                                    methods = [
                                      getBody
                                      quote
                                    ]
                                  }
interpolatedStringHeredocLineBody ::= (interpolation | STRING_FRAGMENT | sigilHeredocEscapeSequence)*
                                      { implements = "org.elixir_lang.psi.Body" }

interpolatedWordsHeredoc ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                             interpolatedWordsHeredocLine*
                             heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.WordsFragmented"
                                 "org.elixir_lang.psi.InterpolatedSigilHeredoc"
                               ]
                               pin = WORDS_HEREDOC_PROMOTER
                             }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
interpolatedWordsHeredocLine ::= heredocLinePrefix interpolatedWordsHeredocLineBody heredocLineEnd
                                 {
                                   implements = [
                                     "org.elixir_lang.psi.HeredocLine"
                                   ]
                                   methods = [
                                     getBody
                                     quote
                                   ]
                                 }
interpolatedWordsHeredocLineBody ::= (interpolation | WORDS_FRAGMENT | sigilHeredocEscapeSequence)*
                                     { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigil Heredocs
 */

literalCharListSigilHeredoc ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_HEREDOC_PROMOTER EOL
                                literalCharListHeredocLine*
                                heredocPrefix CHAR_LIST_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.CharListFragmented"
                                    "org.elixir_lang.psi.LiteralSigilHeredoc"
                                  ]
                                  pin = CHAR_LIST_SIGIL_HEREDOC_PROMOTER
                                }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalCharListHeredocLine ::= heredocLinePrefix literalCharListHeredocLineBody heredocLineEnd
                               {
                                 implements = [
                                   "org.elixir_lang.psi.HeredocLine"
                                 ]
                                 methods = [
                                   getBody
                                   quote
                                 ]
                               }
// literals can have escape sequences for escaped terminator
literalCharListHeredocLineBody ::= (CHAR_LIST_FRAGMENT | sigilHeredocEscapeSequence)*
                                   { implements = "org.elixir_lang.psi.Body" }

literalRegexHeredoc ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_HEREDOC_PROMOTER EOL
                        literalRegexHeredocLine*
                        heredocPrefix REGEX_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.RegexFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = REGEX_HEREDOC_PROMOTER
                        }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalRegexHeredocLine ::= heredocLinePrefix literalRegexHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalRegexHeredocLineBody ::= (REGEX_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

literalSigilHeredoc ::= TILDE LITERAL_SIGIL_NAME SIGIL_HEREDOC_PROMOTER EOL
                        literalSigilHeredocLine*
                        heredocPrefix SIGIL_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.SigilFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = SIGIL_HEREDOC_PROMOTER
                        }
literalSigilHeredocLine ::= heredocLinePrefix literalSigilHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalSigilHeredocLineBody ::= (SIGIL_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

literalStringSigilHeredoc ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_HEREDOC_PROMOTER EOL
                              literalStringHeredocLine*
                              heredocPrefix STRING_SIGIL_HEREDOC_TERMINATOR sigilModifiers
                              {
                                implements = [
                                  "org.elixir_lang.psi.StringFragmented"
                                  "org.elixir_lang.psi.LiteralSigilHeredoc"
                                ]
                                pin = STRING_SIGIL_HEREDOC_PROMOTER
                              }
literalStringHeredocLine ::= heredocLinePrefix literalStringHeredocLineBody heredocLineEnd
                             {
                               implements = [
                                 "org.elixir_lang.psi.HeredocLine"
                               ]
                               methods = [
                                 getBody
                                 quote
                               ]
                             }
// literals can have escape sequences for escaped terminator
literalStringHeredocLineBody ::= (STRING_FRAGMENT | sigilHeredocEscapeSequence)*
                                 { implements = "org.elixir_lang.psi.Body" }

literalWordsHeredoc ::= TILDE LITERAL_WORDS_SIGIL_NAME WORDS_HEREDOC_PROMOTER EOL
                        literalWordsHeredocLine*
                        heredocPrefix WORDS_HEREDOC_TERMINATOR sigilModifiers
                        {
                          implements = [
                            "org.elixir_lang.psi.WordsFragmented"
                            "org.elixir_lang.psi.LiteralSigilHeredoc"
                          ]
                          pin = WORDS_HEREDOC_PROMOTER
                        }
// EOL is optional because when last line EOL is escaped (See https://github.com/KronicDeth/intellij-elixir/issues/1843)
literalWordsHeredocLine ::= heredocLinePrefix literalWordsHeredocLineBody heredocLineEnd
                            {
                              implements = [
                                "org.elixir_lang.psi.HeredocLine"
                              ]
                              methods = [
                                getBody
                                quote
                              ]
                            }
// literals can have escape sequences for escaped terminator
literalWordsHeredocLineBody ::= (WORDS_FRAGMENT | sigilHeredocEscapeSequence)*
                                { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Lines (as opposed to Heredocs)
 *
 *
 */

/*
 *
 * Quote Lines
 *
 */


charListLine ::= CHAR_LIST_PROMOTER charListLineBody CHAR_LIST_TERMINATOR
                 {
                   implements = [
                     "org.elixir_lang.psi.Atomable"
                     "org.elixir_lang.psi.InterpolatedCharList"
                     "org.elixir_lang.psi.Line"
                     "org.elixir_lang.psi.Quotable"
                   ]
                   pin = CHAR_LIST_PROMOTER
                 }

charListLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | lineEscapeSequence)*
                      { implements =  "org.elixir_lang.psi.Body" }

stringLine ::= STRING_PROMOTER stringLineBody STRING_TERMINATOR
               {
                 implements = [
                   "org.elixir_lang.psi.Atomable"
                   "org.elixir_lang.psi.InterpolatedString"
                   "org.elixir_lang.psi.Line"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 pin = STRING_PROMOTER
               }

stringLineBody ::= (interpolation | STRING_FRAGMENT | lineEscapeSequence)*
                   { implements = "org.elixir_lang.psi.Body" }

/*
 *
 * Sigil Lines
 *
 */

/*
 * Interpolated Sigil Lines
 */

interpolatedCharListSigilLine ::= TILDE INTERPOLATING_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER interpolatedCharListSigilLineBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                                  {
                                    implements = [
                                      "org.elixir_lang.psi.CharListFragmented"
                                      "org.elixir_lang.psi.InterpolatedSigilLine"
                                    ]
                                    pin = CHAR_LIST_SIGIL_PROMOTER
                                  }
interpolatedCharListSigilLineBody ::= (interpolation | CHAR_LIST_FRAGMENT | sigilLineEscapeSequence)*
                                      { implements = "org.elixir_lang.psi.Body" }

interpolatedRegexLine ::= TILDE INTERPOLATING_REGEX_SIGIL_NAME REGEX_PROMOTER interpolatedRegexLineBody REGEX_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.RegexFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = REGEX_PROMOTER
                          }
interpolatedRegexLineBody ::= (interpolation | REGEX_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

interpolatedSigilLine ::= TILDE INTERPOLATING_SIGIL_NAME SIGIL_PROMOTER interpolatedSigilLineBody SIGIL_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.SigilFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = SIGIL_PROMOTER
                          }
interpolatedSigilLineBody ::= (interpolation | SIGIL_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

interpolatedStringSigilLine ::= TILDE INTERPOLATING_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER interpolatedStringSigilLineBody STRING_SIGIL_TERMINATOR sigilModifiers
                                {
                                  implements = [
                                    "org.elixir_lang.psi.StringFragmented"
                                    "org.elixir_lang.psi.InterpolatedSigilLine"
                                  ]
                                  pin = STRING_SIGIL_PROMOTER
                                }
interpolatedStringSigilLineBody ::= (interpolation | STRING_FRAGMENT | sigilLineEscapeSequence)*
                                    { implements = "org.elixir_lang.psi.Body" }

interpolatedWordsLine ::= TILDE INTERPOLATING_WORDS_SIGIL_NAME WORDS_PROMOTER interpolatedWordsLineBody WORDS_TERMINATOR sigilModifiers
                          {
                            implements = [
                              "org.elixir_lang.psi.WordsFragmented"
                              "org.elixir_lang.psi.InterpolatedSigilLine"
                            ]
                            pin = WORDS_PROMOTER
                          }
interpolatedWordsLineBody ::= (interpolation | WORDS_FRAGMENT | sigilLineEscapeSequence)*
                              { implements = "org.elixir_lang.psi.Body" }

/*
 * Literal Sigils
 */

literalCharListSigilLine ::= TILDE LITERAL_CHAR_LIST_SIGIL_NAME CHAR_LIST_SIGIL_PROMOTER literalCharListSigilLineBody CHAR_LIST_SIGIL_TERMINATOR sigilModifiers
                             {
                               implements = [
                                 "org.elixir_lang.psi.CharListFragmented"
                                 "org.elixir_lang.psi.LiteralSigilLine"
                               ]
                               pin = CHAR_LIST_SIGIL_PROMOTER
                             }
literalCharListSigilLineBody ::= (CHAR_LIST_FRAGMENT | sigilLineEscapeSequence)*
                                 { implements = "org.elixir_lang.psi.Body" }

literalRegexLine ::= TILDE LITERAL_REGEX_SIGIL_NAME REGEX_PROMOTER literalRegexLineBody REGEX_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.RegexFragmented"
                         "org.elixir_lang.psi.LiteralSigilLine"
                       ]
                       pin = REGEX_PROMOTER
                     }
literalRegexLineBody ::= (REGEX_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

literalSigilLine ::= TILDE LITERAL_SIGIL_NAME SIGIL_PROMOTER literalSigilLineBody SIGIL_TERMINATOR sigilModifiers
                     {
                       implements = [
                         "org.elixir_lang.psi.LiteralSigilLine"
                         "org.elixir_lang.psi.SigilFragmented"
                       ]
                       pin = SIGIL_PROMOTER
                     }
literalSigilLineBody ::= (SIGIL_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

literalStringSigilLine ::= TILDE LITERAL_STRING_SIGIL_NAME STRING_SIGIL_PROMOTER literalStringSigilLineBody STRING_SIGIL_TERMINATOR sigilModifiers
                           {
                             implements = [
                               "org.elixir_lang.psi.StringFragmented"
                               "org.elixir_lang.psi.LiteralSigilLine"
                             ]
                             pin = STRING_SIGIL_PROMOTER
                           }
literalStringSigilLineBody ::= (STRING_FRAGMENT | sigilLineEscapeSequence)*
                               { implements = "org.elixir_lang.psi.Body" }

literalWordsLine ::=  TILDE LITERAL_WORDS_SIGIL_NAME WORDS_PROMOTER literalWordsLineBody WORDS_TERMINATOR sigilModifiers
                      {
                        implements = [
                          "org.elixir_lang.psi.WordsFragmented"
                          "org.elixir_lang.psi.LiteralSigilLine"
                        ]
                        pin = WORDS_PROMOTER
                      }
literalWordsLineBody ::= (WORDS_FRAGMENT | sigilLineEscapeSequence)*
                         { implements = "org.elixir_lang.psi.Body" }

/*
 *
 *
 * Matched Expressions - ordered by outer-most (lowest precedence) to inner-most (highest precedence)
 *
 * See ELIXIR_BNF_DESIGN.md for exanplanation of the naming and nesting pattern used in the matchedExpression rules.
 *
 *
 */

matchedExpression ::= matchedLessThanOnePointSixCaptureNonNumericOperation |
                      matchedInMatchOperation |
                      /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                      matchedWhenNoParenthesesKeywordsOperation |
                      matchedWhenOperation |
                      matchedTypeOperation |
                      matchedPipeOperation |
                      matchedGreaterThanOrEqualToOnePointSixCaptureNonNumericOperation |
                      matchedMatchOperation |
                      matchedOrOperation |
                      matchedAndOperation |
                      matchedComparisonOperation |
                      matchedRelationalOperation |
                      matchedArrowOperation |
                      matchedInOperation |
                      matchedNotInOperation |
                      matchedThreeOperation |
                      matchedTwoOperation |
                      matchedAdditionOperation |
                      matchedMultiplicationOperation |
                      matchedUnaryNonNumericOperation |
                      matchedUnaryOperation |
                      matchedDotCall |
                      // NoParentheses before matchedBracketOperation because brackets only make sense after parentheses.
                      matchedQualifiedNoParenthesesCall |
                      matchedAtUnqualifiedNoParenthesesCall |
                      matchedUnqualifiedNoParenthesesCall |
                      matchedAtNumericBracketOperation |
                      matchedBracketOperation |
                      matchedQualifiedAlias |
                      matchedQualifiedMultipleAliases |
                      matchedQualifiedBracketOperation |
                      matchedQualifiedParenthesesCall |
                      matchedQualifiedNoArgumentsCall |
                      matchedAtUnqualifiedBracketOperation |
                      matchedAtNonNumericOperation | // after matchedQualified because @ binds only before `.`
                      matchedAtOperation | // after matchedQualified because @ binds only before `.`
                      matchedUnqualifiedParenthesesCall |
                      matchedUnqualifiedBracketOperation |
                      matchedUnqualifiedNoArgumentsCall |
                      matchedAccessExpression

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

private nonNumeric ::= !numeric
capturePrefixOperator ::= CAPTURE_OPERATOR
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "&"
                          }
matchedLessThanOnePointSixCaptureNonNumericOperation ::= <<ifVersion 'LT' 'V_1_6'>> capturePrefixOperator nonNumeric matchedExpression
matchedGreaterThanOrEqualToOnePointSixCaptureNonNumericOperation ::= <<ifVersion 'GE' 'V_1_6'>> capturePrefixOperator nonNumeric matchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

inMatchInfixOperator ::= IN_MATCH_OPERATOR
                         {
                           implements = "org.elixir_lang.psi.Operator"
                           methods = [
                                         operatorTokenSet
                                         quote
                                         ]
                           name = "<-, \\\\"
                         }
// implements and methods defined by "infix operations" section above
matchedInMatchOperation ::= matchedExpression inMatchInfixOperator matchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

whenInfixOperator ::= WHEN_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "when"
                      }
/* noParenthesesKeywords needs to be in a separate operation so that only matchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and matchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
matchedWhenNoParenthesesKeywordsOperation ::= matchedExpression whenInfixOperator noParenthesesKeywords
                                              { elementType = matchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
matchedWhenOperation ::= matchedExpression whenInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

typeInfixOperator ::= TYPE_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "::"
                      }
// implements and methods defined by "infix operations" section above
matchedTypeOperation ::= matchedExpression typeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

pipeInfixOperator ::= PIPE_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "|"
                      }
// implements and methods defined by "infix operations" section above
matchedPipeOperation ::= matchedExpression pipeInfixOperator matchedExpression
                         { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */

matchInfixOperator ::= MATCH_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "="
                       }
// implements and methods defined by "infix operations" section above
matchedMatchOperation ::= matchedExpression matchInfixOperator matchedExpression
                          { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

orInfixOperator ::= OR_SYMBOL_OPERATOR | OR_WORD_OPERATOR
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "||, |||, or"
                    }
// implements and methods defined by "infix operations" section above
matchedOrOperation ::= matchedExpression orInfixOperator matchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */
andInfixOperator ::= AND_SYMBOL_OPERATOR | AND_WORD_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "&&, &&&, and"
                     }
// implements and methods defined by "infix operations" section above
matchedAndOperation ::= matchedExpression andInfixOperator matchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

comparisonInfixOperator ::= COMPARISON_OPERATOR
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "!=, ==, =~, !==, ==="
                            }
// implements and methods defined by "infix operations" section above
matchedComparisonOperation ::= matchedExpression comparisonInfixOperator matchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

relationalInfixOperator ::= RELATIONAL_OPERATOR
                            {
                              implements = "org.elixir_lang.psi.Operator"
                              methods = [
                                operatorTokenSet
                                quote
                              ]
                              name = "<, >, <=, >="
                            }
// implements and methods defined by "infix operations" section above
matchedRelationalOperation ::= matchedExpression relationalInfixOperator matchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

arrowInfixOperator ::= ARROW_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "<~, |>, ~>, <<<, <<~, <|>, <~>, >>>, ~>>"
                       }
// implements and methods defined by "infix operations" section above
matchedArrowOperation ::= matchedExpression arrowInfixOperator matchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

inInfixOperator ::= IN_OPERATOR
                    {
                      implements = "org.elixir_lang.psi.Operator"
                      methods = [
                        operatorTokenSet
                        quote
                      ]
                      name = "in"
                    }
// implements defined by "in operations" section above
// methods defined by "infix operations" section above
matchedInOperation ::= matchedExpression inInfixOperator matchedExpression

notInfixOperator ::= NOT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                         methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "not"
                     }
matchedNotInOperation ::= matchedExpression <<ifVersion 'GE' 'V_1_5'>> notInfixOperator inInfixOperator matchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
threeInfixOperator ::= THREE_OPERATOR
                       {
                         implements = "org.elixir_lang.psi.Operator"
                         methods = [
                           operatorTokenSet
                           quote
                         ]
                         name = "^^^"
                       }
// implements and methods defined by "infix operations" section above
matchedThreeOperation ::= matchedExpression threeInfixOperator matchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

twoInfixOperator ::= RANGE_OPERATOR | TWO_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "++, --, .., <>"
                     }
// implements and methods defined by "infix operations" section above
matchedTwoOperation ::= matchedExpression twoInfixOperator matchedExpression
                        { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

/* Unlike other binary operation, additionOperations cannot begin with EOLs: if there are EOLs, then the +/- is
   interpreted as unaryOperation. */
additionInfixOperator ::= ADDITION_OPERATOR | SUBTRACTION_OPERATOR
                          {
                            implements = "org.elixir_lang.psi.Operator"
                            methods = [
                              operatorTokenSet
                              quote
                            ]
                            name = "+, -"
                          }
// implements and methods defined by "infix operations" section above
matchedAdditionOperation ::= matchedExpression additionInfixOperator matchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

multiplicationInfixOperator ::= DIVISION_OPERATOR | MULTIPLICATION_OPERATOR
                                {
                                  implements = "org.elixir_lang.psi.Operator"
                                  methods = [
                                    operatorTokenSet
                                    quote
                                  ]
                                  name = "*, /"
                                }
// implements and methods defined by "infix operations" section above
matchedMultiplicationOperation ::= matchedExpression multiplicationInfixOperator matchedExpression

unaryPrefixOperator ::= (NEGATE_OPERATOR | NUMBER_OR_BADARITH_OPERATOR | UNARY_OPERATOR) eolStar |
                        NOT_OPERATOR !IN_OPERATOR
                        {
                          implements = "org.elixir_lang.psi.Operator"
                          methods = [
                            operatorTokenSet
                            quote
                          ]
                          name = "+, -, !, ^, not, ~~~"
                        }

/*
 * Unary Non-Numeric Operation - non-associative (Elixir < 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

matchedUnaryNonNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> unaryPrefixOperator nonNumeric matchedExpression

/*
 * Unary Operation - non-associative (Elixir >= 1.5.0)
 */

matchedUnaryOperation ::= <<ifVersion 'GE' 'V_1_5'>> unaryPrefixOperator matchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

// left-associative (see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L69)
dotInfixOperator ::= DOT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       name = "."
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                     }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L71
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L121
relativeIdentifier ::= IDENTIFIER_TOKEN |
                       AFTER |
                       AND_SYMBOL_OPERATOR |
                       AND_WORD_OPERATOR |
                       ARROW_OPERATOR |
                       // NOT ASSOCIATION_OPERATOR
                       AT_OPERATOR |
                       // NOT BIT_STRING_OPERATOR because it is a special form
                       CAPTURE_OPERATOR |
                       CATCH |
                       COMPARISON_OPERATOR |
                       DO |
                       DIVISION_OPERATOR |
                       PLUS_OPERATOR |
                       ELSE |
                       END |
                       IN_MATCH_OPERATOR |
                       IN_OPERATOR |
                       // NOT MAP_OPERATOR because it is a special form
                       MATCH_OPERATOR |
                       MINUS_OPERATOR |
                       MULTIPLICATION_OPERATOR |
                       OR_SYMBOL_OPERATOR |
                       OR_WORD_OPERATOR |
                       PIPE_OPERATOR |
                       RANGE_OPERATOR |
                       RELATIONAL_OPERATOR |
                       RESCUE |
                       STAB_OPERATOR |
                       STRUCT_OPERATOR |
                       THREE_OPERATOR |
                       // NOT TUPLE_OPERATOR because it is a special form
                       TWO_OPERATOR |
                       UNARY_OPERATOR |
                       WHEN_OPERATOR |
                       atomKeyword |
                       charListLine |
                       stringLine
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/master/lib/elixir/src/elixir_parser.yrl#L481-L482
private parenthesesPositionalArguments ::= containerArgumentsBase

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L484-L488
parenthesesArguments ::= OPENING_PARENTHESIS
                         (
                          unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L485
                          keywords | // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L486
                          parenthesesPositionalArguments (infixComma keywords)?)? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L487-L488
                         CLOSING_PARENTHESIS
                         {
                           implements = [
                             "org.elixir_lang.psi.Arguments"
                             "org.elixir_lang.psi.QuotableArguments"
                           ]
                           methods = [
                             arguments
                             quoteArguments
                           ]
                         }

// call_args_no_parens_one
noParenthesesOneArgument ::= noParenthesesKeywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L417
                             unqualifiedNoParenthesesManyArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L419
                             /* This should NOT be in matchedExpression as it's not in matched_expr, but in no_parens_expr,
                                but having a rule that starts with matchedExpression is only legal in a rule that extends
                                matchedExpression.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L124-L125 */
                             noParenthesesManyArgumentsStrict |
                             /* MUST be after noParenthesesManyArgumentsStrict so that matchedExpression's inbuilt error handling doesn't match with error.

                                NOTE this is used in both unmatchedExpression and matchedExpression.  Using
                                matchedExpression here ensures the `do` block is only consumed by the left-most
                                unmatchedExpression call and not any of the middle matchedExpression calls.

                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L418
                                @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L609-L610 */
                             matchedExpression
                             {
                               implements = [
                                 "org.elixir_lang.psi.Arguments"
                                 "org.elixir_lang.psi.MaybeModuleName"
                                 "org.elixir_lang.psi.QuotableArguments"
                               ]
                               methods = [
                                 arguments
                                 isModuleName
                                 processDeclarations
                                 quoteArguments
                               ]
                             }

matchedParenthesesArguments ::= CALL parenthesesArguments parenthesesArguments? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L254-255

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

matchedDotCall ::= matchedExpression dotInfixOperator parenthesesArguments parenthesesArguments?
                   {
                     implements = [
                       "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.MatchedDotCall>"
                       "org.elixir_lang.psi.MatchedCall"
                     ]
                     mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedDotCall>"
                     stubClass = "org.elixir_lang.psi.stub.MatchedDotCall"
                   }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedQualifiedNoParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoParenthesesCall"
                                      }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtNonNumericOperation must be after * matchedQualified* and matchedBracketOperation, but
 * matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

matchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument
                                          {
                                            implements = [
                                              "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                              "org.elixir_lang.psi.MatchedCall"
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall>"
                                            stubClass = "org.elixir_lang.psi.stub.MatchedAtUnqualifiedNoParenthesesCall"
                                          }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

matchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.MatchedCall"
                                            "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          ]
                                          methods = [
                                            canonicalName
                                            canonicalNameSet
                                            exportedArity
                                            exportedName
                                            functionName
                                            functionNameElement
                                            getDoBlock
                                            hasDoBlockOrKeyword
                                            isExported
                                            getName
                                            getNameIdentifier
                                            getPresentation
                                            getReference
                                            getStub
                                            getUseScope
                                            isCalling
                                            isCallingMacro
                                            moduleName
                                            primaryArguments
                                            primaryArity
                                            processDeclarations
                                            quote
                                            resolvedFinalArity
                                            resolvedFinalArityRange
                                            resolvedModuleName
                                            resolvedPrimaryArity
                                            resolvedSecondaryArity
                                            secondaryArguments
                                            secondaryArity
                                            setName
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoParenthesesCall"
                                        }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

bracketArguments ::= OPENING_BRACKET
                     (
                      keywords |
                      containerExpression infixCommaMaybe
                     )
                     CLOSING_BRACKET
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

matchedBracketOperation ::= matchedExpression bracketArguments
                            { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

matchedQualifiedAlias ::= matchedExpression dotInfixOperator alias
                          {
                            implements = [
                              "org.elixir_lang.psi.NamedElement"
                              "org.elixir_lang.psi.QualifiedAlias"
                            ]
                            methods = [
                              fullyQualifiedName
                              getName
                              getNameIdentifier
                              getPresentation
                              getReference
                              isModuleName
                              processDeclarations
                              quote
                              setName
                            ]
                          }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
matchedQualifiedMultipleAliases ::= matchedExpression dotInfixOperator multipleAliases

// same rules as tuple, but quoting is different, so separate rule.
multipleAliases ::= OPENING_CURLY
                    containerArgumentsMaybe
                    CLOSING_CURLY
                    {
                      implements = "org.elixir_lang.psi.Quotable"
                      methods = [
                        processDeclarations
                        quote
                      ]
                    }


/*
 * Qualified Identifier Bracket Operation
 */

matchedQualifiedBracketOperation ::= matchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedQualifiedParenthesesCall ::= matchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedParenthesesCall"
                                    }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

matchedQualifiedNoArgumentsCall ::= matchedExpression dotInfixOperator relativeIdentifier !CALL
                                    {
                                      implements = [
                                        "org.elixir_lang.psi.MatchedCall"
                                        "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      ]
                                      mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall>"
                                      stubClass = "org.elixir_lang.psi.stub.MatchedQualifiedNoArgumentsCall"
                                    }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

matchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                         { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * At Numeric Bracket Operation (Elixir >= 1.5.0)
 *
 * Needed so that At consumes numeric, but brackets consume both of them.
 */

matchedAtNumericBracketOperation ::= <<ifVersion 'GE' 'V_1_5'>> atPrefixOperator numeric bracketArguments
                                     { implements = "org.elixir_lang.psi.AtNumericBracketOperation" methods = [quote] }

/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

matchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedParenthesesCall"
                                      }

atPrefixOperator ::= AT_OPERATOR
                     {
                       implements = "org.elixir_lang.psi.Operator"
                       methods = [
                         operatorTokenSet
                         quote
                       ]
                       name = "@"
                     }

/*
 * At Non-Numeric Operation - non-associative (Elixir < 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

matchedAtNonNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> atPrefixOperator nonNumeric matchedExpression

/*
 * At Operation - non-associative (Elixir >= 1.5.0)
 */

matchedAtOperation ::= <<ifVersion 'GE' 'V_1_5'>> atPrefixOperator matchedExpression

/*
 * Unqualified Bracket Operation
 */

matchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                       {
                                         implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                         methods = [quote]
                                       }


/*
 * Unqualified No Arguments Call
 */

matchedUnqualifiedNoArgumentsCall ::= identifier notKeywordPairColon
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.MatchedCall"
                                          "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.MatchedUnqualifiedNoArgumentsCall"
                                      }


matchedAccessExpression ::= accessExpression
                            { elementType = accessExpression }

/*
 * Access expression
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L200-L223
 *
 */

atNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> atPrefixOperator numeric
captureNumericOperation ::= capturePrefixOperator numeric
unaryNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> unaryPrefixOperator numeric

/*
 *
 * Map
 *
 */

/*
 * https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L430-L430
 * shows that '%{}' is injected by the Elixir native tokenizer when '%{' is encountered.  Since Elixir.flex can't inject
 * text, this parser is matching MAP_OPERATOR as just '%' as mapArguments contains the '{'.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L521-L522
 */
mapPrefixOperator ::= STRUCT_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "%"
                      }

private associationInfixOperator ::= ASSOCIATION_OPERATOR

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
containerAssociationOperation ::= containerExpression associationInfixOperator containerExpression
                                  { implements = "org.elixir_lang.psi.AssociationOperation" methods = [quote] }

left maxDotCall ::= dotInfixOperator parenthesesArguments parenthesesArguments?
                    { elementType = matchedDotCall }

left maxQualifiedAlias ::= dotInfixOperator alias
                           { elementType = matchedQualifiedAlias }

left maxQualifiedParenthesesCall ::= dotInfixOperator relativeIdentifier matchedParenthesesArguments
                                     { elementType = matchedQualifiedParenthesesCall }

left maxQualifiedNoArgumentsCall ::= dotInfixOperator relativeIdentifier !CALL
                                     { elementType = matchedQualifiedNoArgumentsCall }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L231
private maxExpression ::= /* matchedBracketOperation because it is first rule after matchedDotCallOperation that will
                             take a `.`. */
                          matchedBracketOperation maxDotCall |
                          /* matchedQualifiedBracketOperation because it is in the Pratt-parsing table for
                             matchedExpression will match matchedQualifiedBracketOperation or anything after it in
                             matchedExpression.  matchedQualifiedBracketOperation is used because it is the next rule
                             after matchedQualifiedAliasOperation. maxQualifiedAlias needs to be `left` and `+` to
                             emulate the POSTFIX behavior for matchedQualifiedAliasOperation.

                             matchedQualifiedAliasOperation cannot be used because the Pratt-parsing table will allow
                             matchedQualifiedAliasOperation to match it or any lower rule. */
                          matchedQualifiedBracketOperation maxQualifiedAlias+ | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedQualifiedNoArgumentsCall because it is first rule after
                            matchedQualifiedParenthesesCall */
                          matchedQualifiedNoArgumentsCall maxQualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          /* matchedAtUnqualifiedBracketOperation and all rules thrugh accessExpression are necessary
                             because all those rules are ATOM or PREFIX so they won't also match lower rules */
                          (
                           matchedAtUnqualifiedBracketOperation |
                           matchedAtNumericBracketOperation |
                           matchedAtNonNumericOperation |
                           matchedAtOperation |
                           matchedUnqualifiedParenthesesCall |
                           matchedUnqualifiedBracketOperation |
                           variable |
                           accessExpression
                          ) maxQualifiedNoArgumentsCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          matchedUnqualifiedParenthesesCall | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231
                          variable | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L499
                          atom | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L226-L228
                          alias // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L231

/*
 * Map Expression
 */

atMaxExpression ::= atPrefixOperator maxExpression
                    { elementType = matchedAtNonNumericOperation }

/* Anything that can hold a map.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L500
 */
private mapExpression ::= maxExpression | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L498-L499
                          atMaxExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L500

private associationsExpression ::= containerAssociationOperation | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L505
                                   mapExpression // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L506
associationsBase ::= associationsExpression (infixComma associationsExpression)*
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
associations ::= associationsBase infixCommaMaybe
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Arguments at tail of mapUpdateArguments and mapConstructionArguments
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524-L526
 */
private mapTailArguments ::= // Must be before associations so identifiers as keyword keys match before maxExpression in associations
                             keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L524
                             associationsBase infixComma keywords | // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L526
                             associations // @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L525

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L530-L533
mapUpdateArguments ::= matchedMatchOperation pipeInfixOperator mapTailArguments
                       { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

mapConstructionArguments ::= mapTailArguments
                             {
                               implements = "org.elixir_lang.psi.QuotableArguments"
                               methods = [
                                 arguments
                                 quoteArguments
                               ]
                             }

mapArguments ::= OPENING_CURLY
                 (
                  // Must be before mapConstructionArguments, so that PIPE_OPERATOR is used for updates and not matchedExpression.
                  mapUpdateArguments |
                  mapConstructionArguments
                 )?
                 CLOSING_CURLY
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }


mapOperation ::= mapPrefixOperator mapArguments
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

structOperation ::= mapPrefixOperator mapExpression eolStar mapArguments
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private map ::= mapOperation |
                structOperation

/*
 * Stab Operation
 */

noParenthesesArguments ::= noParenthesesOneArgument |
                           noParenthesesManyArguments
                           { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L276-L277
stabNoParenthesesSignature ::= noParenthesesArguments
                               { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * `fn (unquote_splicing([1,2,3])) -> end` is valid, but not obvious from elixir_parser.yrl that appears to only allow
 * keywords or many arguments.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L278-L281
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L430-L432
 */
stabParenthesesSignature ::= parenthesesArguments (whenInfixOperator expression)?
                             {
                               implements = [
                                 "org.elixir_lang.psi.Quotable"
                                 "org.elixir_lang.psi.operation.When"
                               ]
                               methods = [
                                 getNameIdentifier
                                 leftOperand
                                 operator
                                 quote
                                 rightOperand
                               ]
                             }

stabInfixOperator ::= STAB_OPERATOR
                      {
                        implements = "org.elixir_lang.psi.Operator"
                        methods = [
                          operatorTokenSet
                          quote
                        ]
                        name = "->"
                      }

/*
 * stabParenthesesSignature must be at same level as stabInfixOperator so that stabParenthesesSignature does not match
 * beginning of stabNoParenthesesSignature that begins with a parentheticalStab, `(one) <op> two ->`.
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L283-L284
 *    for optionalness
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L687-L702
 *    for grouping stab followed by expression into stab, so it is equivalent to expr_list (expressionList)
 */
private stabOperationPrefix ::= stabParenthesesSignature stabInfixOperator |
                                stabNoParenthesesSignature stabInfixOperator
private stabBodyExpression ::= EEX_CLOSING eex EEX_OPENING |
                               expression !(infixComma | stabInfixOperator)
private stabBodyExpressionSeparator ::= EEX_EMPTY_MARKER | endOfExpression
private stabBodyExpressionSeparatorMaybe ::= stabBodyExpressionSeparator?
stabBody ::= stabBodyExpression (stabBodyExpressionSeparator stabBodyExpression)*
             {
               implements = "org.elixir_lang.psi.Quotable"
               methods = [
                 processDeclarations
                 quote
               ]
             }

noArgumentStabOperation ::= stabInfixOperator stabBody?
                            { elementType = stabOperation }
stabOperation ::= stabOperationPrefix stabBody?
                  {
                    implements = "org.elixir_lang.psi.Quotable"
                    methods = [
                      leftOperand
                      operator
                      processDeclarations
                      quote
                      rightOperand
                    ]
                  }

private stabOperations ::= noArgumentStabOperation |
                           stabOperation (stabBodyExpressionSeparator stabOperation)*

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L268-L269
stab ::= stabOperations | stabBody
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L205
anonymousFunction ::= FN endOfExpressionMaybe
                      // -> is required, so use stabOperations directly and not stab as would be used used in `doBlock`
                      stab stabBodyExpressionSeparatorMaybe
                      END
                      {
                        implements = [
                          "com.intellij.psi.NavigatablePsiElement"
                          "org.elixir_lang.psi.Quotable"
                        ]
                        methods = [
                          quote
                        ]
                      }

private semicolonMaybe ::= SEMICOLON?
// @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L206-L210
parentheticalStab ::= OPENING_PARENTHESIS
                      (semicolonMaybe stab semicolonMaybe | SEMICOLON)
                      CLOSING_PARENTHESIS
                      { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Tuple
 */

tuple ::= OPENING_CURLY
          containerArgumentsMaybe
          CLOSING_CURLY
          { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/*
 * Bit String
 */

bitString ::= OPENING_BIT
              containerArgumentsMaybe
              CLOSING_BIT
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

accessExpression ::= atNumericOperation |
                     captureNumericOperation |
                     unaryNumericOperation |
                     anonymousFunction |
                     parentheticalStab |
                     numeric |
                     list |
                     map |
                     tuple |
                     bitString |
                     stringLine notKeywordPairColon |
                     stringHeredoc |
                     charListLine notKeywordPairColon |
                     charListHeredoc |
                     interpolatedCharListSigilLine |
                     interpolatedCharListSigilHeredoc |
                     interpolatedRegexHeredoc |
                     interpolatedSigilHeredoc |
                     interpolatedStringSigilHeredoc |
                     interpolatedWordsHeredoc |
                     interpolatedWordsLine |
                     interpolatedRegexLine |
                     interpolatedSigilLine |
                     interpolatedStringSigilLine |
                     literalCharListSigilLine |
                     literalCharListSigilHeredoc |
                     literalRegexHeredoc |
                     literalSigilHeredoc |
                     literalStringSigilHeredoc |
                     literalWordsHeredoc |
                     literalRegexLine |
                     literalSigilLine |
                     literalStringSigilLine |
                     literalWordsLine |
                     atomKeyword |
                     atom |
                     alias
                     {
                       implements = [
                         "org.elixir_lang.psi.MaybeModuleName"
                         "org.elixir_lang.psi.Quotable"
                       ]
                       methods = [
                         isModuleName
                         quote
                       ]
                     }

// See eexFile in EEx.bnf
eex ::= (EEX_DATA | EEX_ESCAPED_OPENING | eexTag)+
        {
          methods = [
            processDeclarations
          ]
        }

// CANNOT be `{ pin = 1 }` because an `EEX_OPENING` is also used in `doBlock`
eexTag ::= EEX_OPENING (eexCommentBody | eexElixirBody) EEX_CLOSING
           {
             methods = [
               processDeclarations
             ]
           }

private eexCommentBody ::= EEX_COMMENT_MARKER EEX_COMMENT?
                           { pin = 1 }
private eexFunctionalMarker ::= EEX_EQUALS_MARKER | EEX_FORWARD_SLASH_MARKER | EEX_PIPE_MARKER
private eexFunctionalElixirBody ::= eexFunctionalMarker elixirFile
                                    { pin = 1 }
// DO NOT { pin = 1 ] because EEX_EMPTY_MARKER can occur before `END` and `blockItem`
private eexProceduralElixirBody ::= EEX_EMPTY_MARKER elixirFile
private eexElixirBody ::= eexFunctionalElixirBody | eexProceduralElixirBody

// keywords that map to atoms
atomKeyword ::= FALSE | NIL | TRUE
                { implements = "org.elixir_lang.psi.Quotable" methods = [quote] name = "false, nil, true" }

alias ::= ALIAS_TOKEN notKeywordPairColon
          {
            implements = [
              "org.elixir_lang.psi.NamedElement"
              "org.elixir_lang.psi.QualifiableAlias"
              "org.elixir_lang.psi.Quotable"
            ]
            methods = [
              fullyQualifiedName
              getName
              getNameIdentifier
              getPresentation
              getReference
              isModuleName
              processDeclarations
              quote
              setName
            ]
          }

/*
 *
 *
 * Unmatched Expressions
 *
 *
 */

/*
 * Capture Non-Numeric Operation - non-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L50
 */

unmatchedLessThanOnePointSixCaptureNonNumericOperation ::= <<ifVersion 'LT' 'V_1_6'>> capturePrefixOperator nonNumeric unmatchedExpression
unmatchedGreaterThanOrEqualToOnePointSixCaptureNonNumericOperation ::= <<ifVersion 'GE' 'V_1_6'>> capturePrefixOperator nonNumeric unmatchedExpression

/*
 * In Match Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L51
 */

// implements and methods defined by "infix operations" section above
unmatchedInMatchOperation ::= unmatchedExpression inMatchInfixOperator unmatchedExpression

/*
 * When Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L52
 */

/* noParenthesesKeywords needs to be in a separate operation so that only unmatchedWhenNoParenthesesKeywordsOperation is a
   POSTFIX operation and unmatchedWhenOperation can remain a BINARY operation.  With
   `(noParenthesesKeywords | matchedExpression)` as the right operand, matchdWhenExpression was a POSTFIX operator,
   which caused the precedence for matchedInMatchOperand and matchedWhenOperation to be wrong as demonstrated in
   49ffef5a33ca1102213821efb4e2140f97622ca1 by
   org.elixir_lang.parser_definition.MatchedINMatchOperationParsingTestCase.testMatchedWhenOperation. */
unmatchedWhenNoParenthesesKeywordsOperation ::= unmatchedExpression whenInfixOperator noParenthesesKeywords
                                                { elementType = unmatchedWhenOperation rightAssociative = true }
// implements and methods defined by "infix operations" section above
unmatchedWhenOperation ::= unmatchedExpression whenInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Type Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L53
 */

// implements and methods defined by "infix operations" section above
unmatchedTypeOperation ::= unmatchedExpression typeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Pipe Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L54
 */

// implements and methods defined by "infix operations" section above
unmatchedPipeOperation ::= unmatchedExpression pipeInfixOperator unmatchedExpression
                           { rightAssociative = true }

/*
 * Match Operation - right-associative
 *
 * @see see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L56
 */


// implements and methods defined by "infix operations" section above
unmatchedMatchOperation ::= unmatchedExpression matchInfixOperator unmatchedExpression
                            { rightAssociative = true }

/*
 * Or Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L57
 */

// implements and methods defined by "infix operations" section above
unmatchedOrOperation ::= unmatchedExpression orInfixOperator unmatchedExpression

/*
 * And Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L58
 */

// implements and methods defined by "infix operations" section above
unmatchedAndOperation ::= unmatchedExpression andInfixOperator unmatchedExpression

/*
 * Comparison Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L59
 */

// implements and methods defined by "infix operations" section above
unmatchedComparisonOperation ::= unmatchedExpression comparisonInfixOperator unmatchedExpression

/*
 * Relational Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L60
 */

// implements and methods defined by "infix operations" section above
unmatchedRelationalOperation ::= unmatchedExpression relationalInfixOperator unmatchedExpression

/*
 * Arrow Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L61
 */

// implements and methods defined by "infix operations" section above
unmatchedArrowOperation ::= unmatchedExpression arrowInfixOperator unmatchedExpression

/*
 * In Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L62
 */

// implements defined by "in operations" section above
// methods defined by "infix operations" section above
unmatchedInOperation ::= unmatchedExpression inInfixOperator unmatchedExpression

unmatchedNotInOperation ::= unmatchedExpression <<ifVersion 'GE' 'V_1_5'>> notInfixOperator inInfixOperator unmatchedExpression

/*
 * Three Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/3487d00ddb5e90c7cf0e65d03717903b9b27eafd/lib/elixir/src/elixir_parser.yrl#L67
 */
// implements and methods defined by "infix operations" section above
unmatchedThreeOperation ::= unmatchedExpression threeInfixOperator unmatchedExpression

/*
 * Two Operation - right-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L63
 */

// implements and methods defined by "infix operations" section above
unmatchedTwoOperation ::= unmatchedExpression twoInfixOperator unmatchedExpression
                          { rightAssociative = true }

/*
 * Addition Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L64
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedAdditionOperation ::= unmatchedExpression additionInfixOperator unmatchedExpression

/*
 * Multiplication Operation - left-associative
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L65
 *
 */

// implements and methods defined by "infix operations" section above
unmatchedMultiplicationOperation ::= unmatchedExpression multiplicationInfixOperator unmatchedExpression

/*
 * Unary Non-Numeric Operation - non-associative (Elixir < 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L67
 *
 */

unmatchedUnaryNonNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> unaryPrefixOperator nonNumeric unmatchedExpression

/*
 * Unary Operation - non-associative (Elixir >= 1.5.0)
 */

unmatchedUnaryOperation ::= <<ifVersion 'GE' 'V_1_5'>> unaryPrefixOperator unmatchedExpression

/*
 * Dot Operations
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L561-L565
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

private doBlockMaybe ::= doBlock?

/*
 * Dot (Anonymous function) Call Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L403
 */

unmatchedDotCall ::= unmatchedExpression dotInfixOperator parenthesesArguments parenthesesArguments? doBlockMaybe
                     {
                       implements = "org.elixir_lang.psi.DotCall<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedDotCall>"
                       stubClass = "org.elixir_lang.psi.stub.UnmatchedDotCall"
                     }

/*
 * Qualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedQualifiedNoParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier noParenthesesOneArgument doBlockMaybe
                                        {
                                          implements = [
                                            "org.elixir_lang.psi.QualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          ]
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoParenthesesCall"
                                        }

/*
 * At Operation on Unqualified No Parentheses CALL
 *
 * Needed because matchedAtNonNumericOperation must be after *matchedQualified* and *matchedBracketOperation, but
 * *matchedUnqualifiedNoParenthesesCall needs to be an operand of At so that the entire call is an operand instead of
 * just the variable.
 */

atIdentifier ::= atPrefixOperator IDENTIFIER_TOKEN
                 { methods = [getReference] }
unmatchedAtUnqualifiedNoParenthesesCall ::= atIdentifier noParenthesesOneArgument doBlockMaybe
                                            {
                                              implements = "org.elixir_lang.psi.AtUnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall>"
                                              stubClass = "org.elixir_lang.psi.stub.UnmatchedAtUnqualifiedNoParenthesesCall"
                                            }

/*
 * Unqualified No Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L191-L194
 */

unmatchedUnqualifiedNoParenthesesCall ::= identifier noParenthesesOneArgument doBlockMaybe
                                          {
                                            implements = "org.elixir_lang.psi.UnqualifiedNoParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            methods = [
                                              canonicalName
                                              canonicalNameSet
                                              exportedArity
                                              exportedName
                                              functionName
                                              functionNameElement
                                              getDoBlock
                                              hasDoBlockOrKeyword
                                              isExported
                                              getName
                                              getNameIdentifier
                                              getPresentation
                                              getReference
                                              getStub
                                              getUseScope
                                              isCalling
                                              isCallingMacro
                                              moduleName
                                              primaryArguments
                                              primaryArity
                                              processDeclarations
                                              quote
                                              resolvedFinalArity
                                              resolvedFinalArityRange
                                              resolvedModuleName
                                              resolvedPrimaryArity
                                              resolvedSecondaryArity
                                              secondaryArguments
                                              secondaryArity
                                              setName
                                            ]
                                            mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall>"
                                            stubClass="org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoParenthesesCall"
                                          }

/*
 * Bracket Operation
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L238
 */

unmatchedBracketOperation ::= unmatchedExpression bracketArguments
                              { implements = "org.elixir_lang.psi.BracketOperation" methods = [quote] }

/*
 * Qualified Alias
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L388
 */

unmatchedQualifiedAlias ::= unmatchedExpression dotInfixOperator alias
                            {
                              implements = "org.elixir_lang.psi.QualifiedAlias"
                              methods = [
                                fullyQualifiedName
                                getName
                                getNameIdentifier
                                getPresentation
                                getReference
                                isModuleName
                                processDeclarations
                                quote
                                setName
                              ]
                            }

/*
 * Qualified Multiple Alias
 *
 * See https://github.com/elixir-lang/elixir/pull/3666
 */
unmatchedQualifiedMultipleAliases ::= unmatchedExpression dotInfixOperator multipleAliases

/*
 * Qualified Identifier Bracket Operation
 */

unmatchedQualifiedBracketOperation ::= unmatchedExpression dotInfixOperator relativeIdentifier CALL bracketArguments

/*
 * Qualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedQualifiedParenthesesCall ::= unmatchedExpression dotInfixOperator relativeIdentifier matchedParenthesesArguments doBlockMaybe
                                      {
                                        implements = "org.elixir_lang.psi.QualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedParenthesesCall"
                                      }

/*
 * Qualified Call with No Arguments - neither parenthes nor no parentheses
 */

unmatchedQualifiedNoArgumentsCall ::= unmatchedExpression dotInfixOperator relativeIdentifier !CALL doBlockMaybe
                                      {
                                        implements = [
                                          "org.elixir_lang.psi.QualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        ]
                                        mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall>"
                                        stubClass = "org.elixir_lang.psi.stub.UnmatchedQualifiedNoArgumentsCall"
                                      }

/*
 * At Unqualified Bracket Operation
 *
 * Needed so that At consumes Unqualified identifier, but brackets consume both of them.
 */

unmatchedAtUnqualifiedBracketOperation ::= atPrefixOperator IDENTIFIER_TOKEN CALL bracketArguments
                                           { implements = "org.elixir_lang.psi.AtUnqualifiedBracketOperation" methods = [quote] }

/*
 * At Numeric Operation (Elixir >= 1.5.0)
 *
 * Needed so that At consumes numeric, but brackets consume both of them.
 */

unmatchedAtNumericBracketOperation ::= <<ifVersion 'GE' 'V_1_5'>> atPrefixOperator numeric bracketArguments
                                       { implements = "org.elixir_lang.psi.AtNumericBracketOperation" methods = [quote] }


/*
 * Unqualified Parentheses Call
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L229-L230
 */

unmatchedUnqualifiedParenthesesCall ::= identifier matchedParenthesesArguments doBlockMaybe
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedParenthesesCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedParenthesesCall"
                                        }

/*
 * At Non-Numeric Operation - non-associative (Elixir < 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

unmatchedAtNonNumericOperation ::= <<ifVersion 'LT' 'V_1_5'>> atPrefixOperator nonNumeric unmatchedExpression

/*
 * At Operation - non-associative (Elixir >= 1.5.0)
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L70
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L567-L572
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L574-L578
 */

unmatchedAtOperation ::= <<ifVersion 'GE' 'V_1_5'>> atPrefixOperator unmatchedExpression

/*
 * Unqualified Bracket Operation
 */

unmatchedUnqualifiedBracketOperation ::= identifier CALL bracketArguments
                                         {
                                           implements = "org.elixir_lang.psi.UnqualifiedBracketOperation"
                                           methods = [quote]
                                         }

/*
 * Unqualified No Arguments Call
 */

unmatchedUnqualifiedNoArgumentsCall ::= identifier notKeywordPairColon doBlockMaybe
                                        {
                                          implements = "org.elixir_lang.psi.UnqualifiedNoArgumentsCall<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          mixin = "org.elixir_lang.psi.impl.NamedStubbedPsiElementBase<org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall>"
                                          stubClass = "org.elixir_lang.psi.stub.UnmatchedUnqualifiedNoArgumentsCall"
                                        }

unmatchedAccessExpression ::= accessExpression
                              { elementType = accessExpression }

/*
 *
 * Do Block
 *
 */

/*
 * Block Identifier
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L946
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_tokenizer.erl#L977-L981
 */
blockIdentifier ::= AFTER | CATCH | ELSE | RESCUE
                    { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313-L314
blockItem ::= blockIdentifier endOfExpressionMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L290-L291
              (stab endOfExpressionMaybe)? // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L313
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L316-L317
blockList ::= blockItem+
              { implements = "org.elixir_lang.psi.QuotableArguments" methods = [quoteArguments] }
private eexWhitespace ::= EEX_CLOSING EEX_OPENING EEX_EMPTY_MARKER
private doStabSeparator ::= endOfExpression | eexWhitespace
private doStabSeparatorMaybe ::= doStabSeparator?
// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L272-L275
doBlock ::= DO doStabSeparatorMaybe
            stab? stabBodyExpressionSeparatorMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L273
            blockList? stabBodyExpressionSeparatorMaybe // @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L274
            END
            {
              implements = "org.elixir_lang.psi.QuotableArguments"
              methods = [quoteArguments]
              pin = DO
            }


// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L143-L148
unmatchedExpression ::= unmatchedLessThanOnePointSixCaptureNonNumericOperation |
                        unmatchedInMatchOperation |
                        /* noParenthesesKeywords needs to be first as matchedExpression will match due to the error
                         handling built into the Pratt parser. */
                        unmatchedWhenNoParenthesesKeywordsOperation |
                        unmatchedWhenOperation |
                        unmatchedTypeOperation |
                        unmatchedPipeOperation |
                        unmatchedGreaterThanOrEqualToOnePointSixCaptureNonNumericOperation |
                        unmatchedMatchOperation |
                        unmatchedOrOperation |
                        unmatchedAndOperation |
                        unmatchedComparisonOperation |
                        unmatchedRelationalOperation |
                        unmatchedArrowOperation |
                        unmatchedInOperation |
                        unmatchedNotInOperation |
                        unmatchedThreeOperation |
                        unmatchedTwoOperation |
                        unmatchedAdditionOperation |
                        unmatchedMultiplicationOperation |
                        unmatchedUnaryNonNumericOperation |
                        unmatchedUnaryOperation |
                        unmatchedDotCall |
                        // NoParentheses before unmatchedBracketOperation because brackets only make sense after parentheses.
                        unmatchedQualifiedNoParenthesesCall |
                        unmatchedAtUnqualifiedNoParenthesesCall |
                        unmatchedUnqualifiedNoParenthesesCall |
                        unmatchedAtNumericBracketOperation |
                        unmatchedBracketOperation |
                        unmatchedQualifiedAlias |
                        unmatchedQualifiedMultipleAliases |
                        unmatchedQualifiedBracketOperation |
                        unmatchedQualifiedParenthesesCall |
                        unmatchedQualifiedNoArgumentsCall |
                        unmatchedAtUnqualifiedBracketOperation |
                        unmatchedAtNonNumericOperation | // after unmatchedQualified because @ binds only before `.`
                        unmatchedAtOperation | // after unmatchedQualified because @ binds only before `.`
                        unmatchedUnqualifiedParenthesesCall |
                        unmatchedUnqualifiedBracketOperation |
                        unmatchedUnqualifiedNoArgumentsCall |
                        unmatchedAccessExpression

/*
 *
 *
 * Whole Numbers
 *
 *
 *
 */

decimalDigits ::= INVALID_DECIMAL_DIGITS | VALID_DECIMAL_DIGITS
                  { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
decimalWholeNumber ::= decimalDigits (NUMBER_SEPARATOR? decimalDigits)*
                        {
                          implements = "org.elixir_lang.psi.WholeNumber"
                          methods = [
                            base
                            digitsList
                            quote
                          ]
                        }

/*
 *
 * Base (Non-Decimal) Whole Numbers
 *
 */

/*
 * Binary (2)
 */

binaryDigits ::= INVALID_BINARY_DIGITS | VALID_BINARY_DIGITS
                 { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
binaryWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (BINARY_WHOLE_NUMBER_BASE | OBSOLETE_BINARY_WHOLE_NUMBER_BASE) binaryDigits (NUMBER_SEPARATOR? binaryDigits)*
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Hexadecimal (16)
 */

hexadecimalDigits ::= INVALID_HEXADECIMAL_DIGITS | VALID_HEXADECIMAL_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
hexadecimalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX (HEXADECIMAL_WHOLE_NUMBER_BASE | OBSOLETE_HEXADECIMAL_WHOLE_NUMBER_BASE) hexadecimalDigits (NUMBER_SEPARATOR? hexadecimalDigits)*
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin = 2
                           }

/*
 * Octal (8)
 */

octalDigits ::= INVALID_OCTAL_DIGITS | VALID_OCTAL_DIGITS
                { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
octalWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX OCTAL_WHOLE_NUMBER_BASE octalDigits (NUMBER_SEPARATOR? octalDigits)*
                     {
                       implements = "org.elixir_lang.psi.WholeNumber"
                       methods = [
                         base
                         digitsList
                         quote
                       ]
                       pin = 2
                     }

/*
 * Unknown (1-36)
 */

unknownBaseDigits ::= INVALID_UNKNOWN_BASE_DIGITS
                      { implements = "org.elixir_lang.psi.Digits" methods = [base inBase quote validElementType] }
unknownBaseWholeNumber ::= BASE_WHOLE_NUMBER_PREFIX UNKNOWN_WHOLE_NUMBER_BASE unknownBaseDigits+
                           {
                             implements = "org.elixir_lang.psi.WholeNumber"
                             methods = [
                               base
                               digitsList
                               quote
                             ]
                             pin=2
                           }

/*
 *
 *
 * In alphabetical order
 *
 *
 */

atom ::= COLON (ATOM_FRAGMENT | quote)
         {
           implements = [
             "com.intellij.psi.NavigatablePsiElement"
             "org.elixir_lang.psi.Quotable"
           ]
           methods = [
             getReference
             quote
           ]
         }

private infixComma ::= COMMA eolStar
private infixCommaMaybe ::= infixComma?

charToken ::= CHAR_TOKENIZER (CHAR_LIST_FRAGMENT | lineEscapeSequence)
              { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

private containerExpression ::= emptyParentheses |
                                unmatchedExpression

decimalFloat ::= decimalFloatIntegral DECIMAL_MARK decimalFloatFractional (EXPONENT_MARK decimalFloatExponent)?
                 { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
decimalFloatExponent ::= decimalFloatExponentSign? decimalWholeNumber
decimalFloatExponentSign ::= SIGN_OPERATOR
decimalFloatFractional ::= decimalWholeNumber
decimalFloatIntegral ::= decimalWholeNumber

/*
 *
 * Escape Sequences
 *
 */

/*
 * Shared subrules
 */

hexadecimalEscapePrefix ::= ESCAPE (HEXADECIMAL_WHOLE_NUMBER_BASE | UNICODE_ESCAPE_CHARACTER)
enclosedHexadecimalEscapeSequence ::= OPENING_CURLY VALID_HEXADECIMAL_DIGITS CLOSING_CURLY
                                      { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] pin = 1 }
openHexadecimalEscapeSequence ::= VALID_HEXADECIMAL_DIGITS
                                  { implements = "org.elixir_lang.psi.EscapedHexadecimalDigits" methods = [codePoint] }
escapedCharacter ::= ESCAPE ESCAPED_CHARACTER_TOKEN
                     { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }
escapedEOL ::= ESCAPE EOL
               { implements = "org.elixir_lang.psi.EscapeSequence" methods = [codePoint] }
private heredocLineEnd ::= (escapedEOL | EOL)

/*
 * Quotes (charListHeredoc, charListLine, stringHeredoc, stringLine)
 */

/*
 * Does not contain `escapedEOL` as heredocs require EOL to end each line even if they are escaped by the user
 */
private heredocEscapeSequence ::= quoteHexadecimalEscapeSequence |
                                  escapedCharacter

private lineEscapeSequence ::= quoteHexadecimalEscapeSequence |
                               escapedEOL |
                               /* Must be last so that ESCAPE ('\') can be pinned in escapedCharacter without excluding
                                  ("\x") in hexadecimalEscapeSequence  */
                               escapedCharacter
quoteHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                     pin = 1
                                   }

/*
 * Keywords
 */

keywordKey ::= AFTER |
               ALIAS_TOKEN |
               AND_SYMBOL_OPERATOR |
               AND_WORD_OPERATOR |
               ARROW_OPERATOR |
               ASSOCIATION_OPERATOR |
               ATOM_FRAGMENT |
               AT_OPERATOR |
               BIT_STRING_OPERATOR |
               CAPTURE_OPERATOR |
               CATCH |
               COMPARISON_OPERATOR |
               DO |
               DIVISION_OPERATOR |
               ELSE |
               END |
               FALSE |
               IN_MATCH_OPERATOR |
               IN_OPERATOR |
               MAP_OPERATOR |
               MATCH_OPERATOR |
               MINUS_OPERATOR |
               MULTIPLICATION_OPERATOR |
               NIL |
               NOT_OPERATOR |
               OR_SYMBOL_OPERATOR |
               OR_WORD_OPERATOR |
               PIPE_OPERATOR |
               PLUS_OPERATOR |
               RANGE_OPERATOR |
               RESCUE |
               RELATIONAL_OPERATOR |
               SIGN_OPERATOR |
               STAB_OPERATOR |
               STRUCT_OPERATOR |
               THREE_OPERATOR |
               TRUE |
               TUPLE_OPERATOR |
               TWO_OPERATOR |
               UNARY_OPERATOR |
               WHEN_OPERATOR |
               quote
               {
                 implements = [
                   "org.elixir_lang.psi.NamedElement"
                   "org.elixir_lang.psi.Quotable"
                 ]
                 methods = [
                   getName
                   getNameIdentifier
                   getPresentation
                   quote
                   setName
                 ]
               }
// @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499
private keywordKeyColon ::= keywordKey KEYWORD_PAIR_COLON

/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L499 */
keywordPair ::=  keywordKeyColon containerExpression
                 {
                   implements = "org.elixir_lang.psi.QuotableKeywordPair"
                   methods = [
                     getKeywordKey
                     getKeywordValue
                     quote
                   ]
                 }
/* @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L500
   @see https://github.com/elixir-lang/elixir/blob/39b6789a8625071e149f0a7347ca7a2111f7c8f2/lib/elixir/src/elixir_parser.yrl#L502-L503 */
keywords ::= keywordPair (infixComma keywordPair)* COMMA?
             { implements = "org.elixir_lang.psi.QuotableKeywordList" methods = [quotableKeywordPairList quote] }

/*
 * Sigil
 */

private sigilLineEscapeSequence ::= sigilHexadecimalEscapeSequence |
                                    hexadecimalEscapePrefix |
                                    escapedEOL |
                                    escapedCharacter
// Does not pin so that escapePrefix can match separately as `\x` and `\u` is valid for sigils
sigilHexadecimalEscapeSequence ::= hexadecimalEscapePrefix (openHexadecimalEscapeSequence | enclosedHexadecimalEscapeSequence)
                                   {
                                     implements = "org.elixir_lang.psi.EscapeSequence"
                                     methods = [codePoint]
                                   }
private sigilHeredocEscapeSequence ::= sigilHexadecimalEscapeSequence |
                                       hexadecimalEscapePrefix |
                                       escapedCharacter

emptyParentheses ::= OPENING_PARENTHESIS CLOSING_PARENTHESIS
                     { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }
interpolation ::= INTERPOLATION_START elixirFile INTERPOLATION_END

/*
 * List
 *
 * @see https://github.com/elixir-lang/elixir/blob/de39bbaca277002797e52ffbde617ace06233a2b/lib/elixir/src/elixir_parser.yrl#L476-L484
 */

private containerArgumentsBase ::= containerExpression (infixComma containerExpression)*
private containerArguments ::= containerArgumentsBase (infixComma keywords | infixComma)?
private containerArgumentsMaybe ::= containerArguments?

private listArguments ::= keywords |
                          containerArguments

list ::= OPENING_BRACKET
         listArguments?
         CLOSING_BRACKET
         { implements = "org.elixir_lang.psi.Quotable" methods = [quote] }

/* elixir_tokenizer.erl converts CHAR_TOKEN_TOKENs to their number representation, so `number` in elixir_parser.yrl matches
   Elixir.flex's CHAR_TOKEN_TOKEN and all the different base number rules. */
private numeric ::= charToken |
                    binaryWholeNumber |
                    // decimalFloat starts with decimalWholeNumber, so decimalFloat needs to be first
                    decimalFloat |
                    decimalWholeNumber |
                    hexadecimalWholeNumber |
                    octalWholeNumber |
                    unknownBaseWholeNumber

private quote ::= (charListLine | stringLine)
