<html>
<body>
<h1>v12.1.0</h1>
<ul>
  <li>
    <p>Enhancements</p>
    <ul dir="auto">
      <li>Update build to elixir 1.13.0</li>
      <li>Add support for ** operator to lexer and parser<br>
        Port <a href="https://github.com/elixir-lang/elixir/pull/11241">Add power operator</a>
      </li>
    </ul>
  </li>
  <li>
    <p>Bug Fixes</p>
    <ul dir="auto">
      <li>
        <p dir="auto">Restore tests that weren't being run after 2021.3 upgrade.<br>
          Upgrading to 2021.3 dropped the number of run tests from 3741 to 1452.  This was due to a change in the packaging in 2021.3 that triggered a gradle bug.</p>
        <ul dir="auto">
          <li>Fix test broken by missing <code>markdown</code> in plugins list<br>
            Like the need for the <code>java</code> plugin to handle the <code>com.intellij.modules.java</code> <code>depends</code>in <code>plugin.xml</code>, the <code>org.intellij.plugins.markdown</code> <code>depends</code> needed <code>markdown</code> added to the list to make some of the tests work.  The failed tests weren't being run before after the 2021.3 upgrade.</li>
          <li>Manually include tests instead of scanning.<br>
            Work-around <a href="https://github.com/gradle/gradle/issues/18486">gradle/gradle#18486</a> as described in <a href="https://jetbrains-platform.slack.com/archives/C5U8BM1MK/p1637955960051600?thread_ts=1637923961.040000&amp;cid=C5U8BM1MK" rel="nofollow">this JetBrains Platform Slack #intellij-platform channel thread</a> that affects running tests with ideaVersion 2021.3.
            <ul dir="auto">
              <li>Rename ParsingTestCases with improper capitalization</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Decompile <code>{:|, ..., ...}</code> as cons operator in Elixir Dbgi.</li>
      <li>Fix missing guards when decompiling Elixr DbgI clauses using special decompiler<br>
        Guards where missing because only <code>decompiler.appendSignature</code> was used.</li>
      <li>Fix <strong>module</strong>.Reference.calculateDefaultRangeInElement<br>
        <code>element.textOffset</code> instead of <code>element.textLength</code> was used for end of range.</li>
    </ul>
  </li>
</ul>
<h1>v12.0.1</h1>
<ul>
  <li>
    <p>Bug Fixes</p>
    <ul dir="auto">
      <li>Override <code>Override org.elixir_lang.*.configuration.Factory.getId</code> to fix deprecation warning about the default implementation being accidentally localizable when it shouldn't be.  The Elixir plugin didn't localize these name using message bundles, so this wasn't an actual risk, but overriding is the only way to silence the error.</li>
      <li>Stop look for qualifier at curly braces for <code>%{Alias}</code></li>
    </ul>
  </li>
</ul>
<h1>v12.0.0</h1>
<ul>
  <li>
    <p>Breaking Changes</p>
    <ul>
      <li>Drop support for Elixir &lt;= 1.6.<br>
        Continuing support for Elixir &lt;= 1.6 required special handling of the language level to support differences
        in precedence and operators.  Removing the language level tracking allows dropping the <code>Level</code> and
        <code>FilePropertyPusher</code> classes and all their usages, including in the parser grammar and the special
        <code>ifVersion</code> external rule.  It also eliminates the need for tests to setup the SDK since it was only
        needed to get the appropriate Level.  This makes the tests run in 45 seconds instead of 7 minutes.
      </li>
      <li>Remove code dependent on the Erlang plugin<br>
        <a href="https://github.com/ignatov/intellij-erlang/issues/963#issuecomment-986261646" data-hovercard-type="issue" data-hovercard-url="/ignatov/intellij-erlang/issues/963/hovercard">Erlang plugin is not 2021.3 compatible yet</a></li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Resolve more calls and bindings in <code>Ecto.Query</code> calls
        <ul>
          <li>Resolve bindings in <code>Ecto.Query.lock/3</code></li>
          <li>Resolve bindings in <code>Ecto.Query.windows/3</code></li>
          <li>Walk <code>preload</code> binding and expression</li>
          <li>Resolve in <code>update</code> for Ecto.Query</li>
          <li>Resolve <code>fragment</code> in <code>with_cte</code></li>
          <li>Resolve <code>binding</code> and <code>expr</code> in <code>Ecto.Query.dynamic/1-2</code></li>
          <li>
            Resolve <code>field</code> in <code>join(..., on: field(..., ...) ...)</code><br>
            For <code>join/5</code>, descend into the options to look for <code>on: value</code> and then walk
            <code>value</code> the same as the value to <code>having</code> or <code>where</code> in selects since
            they're all boolean conditions.
          </li>
          <li>Extract <code>ecto.query.Nested</code></li>
          <li>Resolve <code>Ecto.Query.WindowAPI</code> functions</li>
          <li>
            <p>Resolve reference variable src in <code>join(query, ..., [{src, counter}], ..., ...)</code><br>
              Tuple lists in join have two forms:</p>
            <ol>
              <li><code>{^assoc, a}</code></li>
              <li><code>{src, counter}</code></li>
            </ol>
            <p>
              The pinned association form was already handled because the second element was checked for a declaration,
              but the first element was not, so <code>src</code> in (2) could not be resolved.
            </p>
          </li>
          <li><code>from([..] in ...)</code></li>
          <li>Treat <code>or_having</code> the same as <code>having</code></li>
          <li>Treat <code>or_where</code> the same as <code>where</code></li>
          <li>Treat <code>having:</code> the same as <code>where:</code> in <code>from</code></li>
          <li>
            Treat <code>select_merge</code> the same as <code>select</code> for resolving <code>Ecto.Query.API</code>.
          </li>
          <li><code>from(..., [elements])</code></li>
          <li>Resolve Ecto reference variables in <code>left in ...</code></li>
        </ul>
      </li>
      <li><code>ModuleWalker</code> and <code>NameArityRangeWalker</code><br>
        Reduce code by abstracting common pattern for walking library APIs.</li>
      <li><code>ExUnit</code>
        <ul>
          <li>Find modules declared in <code>test</code>s.</li>
          <li>Resolve call definitions inside <code>describe</code> blocks.</li>
          <li>Resolve variables in <code>assert_receive</code> and <code>assert_received</code>.</li>
          <li>Resolve <code>alias</code> to modules defined inside the enclosing <code>describe</code> block.</li>
          <li>Walk <code>assert</code> expression for variable declarations
            <ul>
              <li>Check for earlier bindings of variables in right operand of <code>=</code> in <code>assert</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve <code>require</code> <code>as:</code> arguments as Aliases</li>
      <li>Decompiler
        <ul>
          <li>Erlang
            <ul>
              <li>Decompile private Erlang functions</li>
              <li>Decompile specs from Erlang DbgI</li>
              <li>Decompile function bodies from Erlang DbgI
                <ul>
                  <li>Escape "in" when an Erlang Var in type</li>
                </ul>
              </li>
              <li>Decompile types from Erlang DbgI<br>
                Fixes #2017</li>
            </ul>
          </li>
          <li>Decompile Elixir function bodies using DbgI
            <ul>
              <li>:erlang./(a, b) -&gt; a / b</li>
              <li>:erlang.*(a, b) -&gt; a * b</li>
              <li>Convert :erlang.==(a,b) to a == b</li>
              <li>Rewrite case to <code>and</code> when there is a badbool error too</li>
              <li>Decompile %{<strong>struct</strong>: name, ...} as %name{...}</li>
              <li>Rewrite more :erlang functions to Elixir</li>
              <li>Rewrite case to ||</li>
              <li>Rewrite <code>case expr1 do pat1 -&gt; true; _ -&gt; false; end</code> to <code>match?(pat1, expr1)</code></li>
              <li>Rewrite <code>if var do false else true</code> to <code>!var</code></li>
              <li>Rewrite case to or</li>
              <li>Rewrite case to and</li>
              <li>Rewrite :erlang.error(E.exception(M)) to raise E, M</li>
              <li>Rewrite case statements to if</li>
              <li>Rewrite case statements to &amp;&amp;</li>
              <li>Indent all lines of spec macro string in case it is multiple <a class="user-mention" data-hovercard-type="organization" data-hovercard-url="/orgs/SPEC/hovercard" href="https://github.com/SPEC">@SPEC</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve module attributes defined outside the immediate modular lexical scope
        <ul>
          <li>
            <p>Resolve module attributes registered in <code>elixir_module.erl</code> to decompiled source</p>
            <ul>
              <li>after_compile</li>
              <li>before_compile</li>
              <li>behaviour</li>
              <li>compile</li>
              <li>derive</li>
              <li>dialyzer</li>
              <li>external_resource</li>
              <li>on_definition</li>
            </ul>
          </li>
          <li>
            <p>Index module attributes<br>
              Use the index to resolve module attributes when it can't be found directly by tree walking.</p>
            <ul>
              <li>Defined with <code>Module.put_attribute/3</code></li>
              <li>Defined with <code>Module.register_attribute/3</code></li>
              <li>Defined in <code>quote</code> blocks</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve variables to variables in any <code>quote</code> blocks<br>
        If a variable can't be resolved in the scope, try resolving it to any variable declared at the top-level of a <code>quote</code> block.  This helps with certain patterns of <code>quote</code> blocks used in Ecto where a variable's declaration and usage are not in the same <code>quote</code> block.</li>
      <li>Simplify CallDefinitionClause resolver for modulars<br>
        Due to the addition of skipping if the entrance is a child call, the check for only following siblings is no longer needed.  Additionally, that check caused a bug because the <code>ElixirStabBody</code> skipped call definitions because they were new scopes.</li>
      <li>Resolve functions declared with <code>Mix.Generator.embed_template</code> and <code>embed_text</code>.<br>
        Also, new system for tracking resolves paths - <code>import</code>s, <code>defdelegate</code>, and <code>use</code> calls are added to the resolve results after the preferred elements are chosen for source in the same module.  This prevents only the <code>import</code> showing because the actual declaration is in another module or the SDK.</li>
      <li>Record a call as visited in its <code>treeWalkUp</code> instead of requiring the caller to do it in the pass <code>ResolveState</code>
        <ul>
          <li>Record <code>quoteCall</code> as visited in <code>QuoteMacro.treeWalkUp</code></li>
          <li>Record <code>unquoteCall</code> as visited in <code>Unquote.treeWalkUp</code></li>
          <li>Record <code>unlessCall</code> as visited in <code>Unless.treeWalkUp</code></li>
          <li>Record <code>ifCall</code> as visited in <code>If.treeWalkUp</code></li>
          <li>Record <code>importCall</code> as visited in <code>Import.treeWalkUp</code></li>
          <li>Record <code>useCall</code> as visited in <code>Use.treeWalkUp</code></li>
        </ul>
      </li>
      <li>More macro specialized in Structure View
        <ul>
          <li><code>test</code></li>
          <li><code>describe</code></li>
        </ul>
      </li>
      <li>Resolve <code>Qualifer.unquote(variable)(...)</code> to any definition with correct arity in <code>Qualifier</code>.</li>
      <li>Only calculate <code>element.resolvedFinalArity</code> once in <code>resolvedQualified</code></li>
      <li>Implementations and Protocols
        <ul>
          <li>Redo icons</li>
          <li>Implementations Go To Protocol line markers</li>
          <li>Go to Super for calls to <code>defimpl</code> function/macro<br>
            Goes to corresponding name/arity in the <code>defprotocol</code> that the <code>defimpl</code> implements.</li>
          <li>Go to implementations line marker from defprotocol def</li>
          <li>Go to implementations line marker from defprotocol</li>
          <li>Go To Implementation from individual functions in defimpl</li>
          <li>Go To Implementation from defimpl Alias</li>
          <li>Resolve protocol function to <code>def</code> in defprotocol</li>
          <li>Resolve defp inside of defimpl<br>
            Process declarations inside of implementation the same as modules.</li>
        </ul>
      </li>
      <li>Stop <code>prependQualifiers</code> at top of file</li>
      <li>Walk the false and true (else) branch of unless in Modules or Quote</li>
      <li>Walk the true and false (else) branch of if in Modules or Quote</li>
      <li>Regression test for <a href="https://github.com/KronicDeth/intellij-elixir/issues/2198">#2198</a></li>
      <li>Use callbacks as completions for calls.</li>
      <li>Decompiler
        <ul>
          <li>
            Don't require <code>MacroNameArity</code> for <code>accept</code>, but use <code>NameArity</code> only
            because no decompiler cares about the macro.
          </li>
        </ul>
      </li>
      <li>Tests for Code.Identifier and String.Tokenizer</li>
      <li>Structure View for <code>EEx.function_from_(file|string)</code></li>
      <li>Variants (completion) for functions declared by special macros.
        <ul>
          <li>Functions defined by <code>EEx.function_from_(file|string)</code></li>
          <li><code>exception/1</code> and <code>message/1</code> defined by <code>defexception</code></li>
          <li>
            <code>*_text/0</code> and <code>*_template(assigns)</code> functions defined by
            <code>Mix.Generator.embed_text</code> and <code>Mix.Generator.embed_template</code>.
          </li>
        </ul>
      </li>
      <li>Internal Tool for BEAM Bulk Decompilation<br>
        Decompile all .beam files in the project, modules and SDKs to check for errors in the generated Elixir code</li>
      <li>Decompiler
        <ul dir="auto">
          <li>Erlang Abst
            <ul dir="auto">
              <li>Log decompilation errors</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Error Reports
        <ul dir="auto">
          <li>Include system information in error reports<br>
            Instead of just including the plugin version, also include the Application name, edition, and version; and the Operation System name and version as these are common follow-up questions I have.</li>
          <li>Remove tab at start of location for title of issues</li>
          <li>Don't include "java.lang.Throwable: " in title of issues<br>
            The <code>Throwable</code> is necessary to get a stacktrace, but not a real error.</li>
        </ul>
      </li>
      <li>Build against <code>2021.3</code></li>
      <li><code>runPluginVerifier</code> in GitHub Actions
        <ul dir="auto">
          <li>Update IDEA version range supports and verified</li>
          <li>Fix reported compatibility warnings
            <ul dir="auto">
              <li>Inline deprecated bundle messages</li>
              <li>Don't bundle built-in markdown plugin, depend on it instead</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>Alternative function clause for <code>put_event</code> with <code>suite_finished</code></li>
      <li>StackOverflow fixes
        <ul>
          <li>
            getElementDescription(ElixirAtom, ElementDescriptionLocation)<br>
            Override getElementDescription for atoms to prevent StackOverflow while looking for a provider.
          </li>
          <li>
            Don't descend into either branch of <code>if</code> or <code>unless</code> if entrance in either branch when resolving calls.<br>
            If the definition were in one of the branch, it would already have been found on processing previous siblings in the <code>ElixirStabBody</code>.
          </li>
          <li>
            Treat child of modulars as being at the same level if nested in <code>if</code> or <code>unless</code><br>
            Prevents <code>test</code> in <code>if</code> in <code>supervisor_test.exs</code> in <code>ecto</code> from stack overflowing.
          </li>
          <li>
            Fix StackOverflow when looking for earlier bindings in parameters.
          </li>
          <li>
            <p>Don't check following siblings of modulars if entrance is a direct child</p>
            <p>Prevent StackOverflow when trying to resolve embed_template when more than one appears in the same module.</p>
            <p>In general, if the entrance is a child of modular then it can only be defined by a previous sibling, usually an <code>import</code> or <code>use</code>, but if the entrance is descendant of a child, then it child then it may be a call to a function or macro defined in the modular to following siblings of the entrance ancestor child needs to be checked if the entrance is a forward-call to a later declared function or macro.</p>
          </li>
          <li>
            Fix StackOverflowError in ifErlangRewriteTo<br>
            Don't rewriter :erlang.* to a different :erlang.*
          </li>
        </ul>
      </li>
      <li>Adjust nameArityInterval in nameArityInAnyModule<br>
        Ensures that <code>fragment/1..</code> used in a <code>quote</code> can resolve to one in <code>Ecto.Query.API</code>.</li>
      <li>Resolve variable that are the only child of <code>quote</code><br>
        Ecto loves doing <code>quote do: query</code> or other variable names in the code and tests, so record those as declarations to resolve as invalid results.</li>
      <li>Find enclosing macro call when keyword <code>do:</code> is surrounded by parentheses<br>
        Previously, only <code>quote do: variable</code> would work, but now <code>quote(do: variable)</code> also works to find the <code>quote</code> call.</li>
      <li>Don't mark fields and keys that are not expected to be resolvable yet as unresolvable in Elixir References inspection.
        <ul>
          <li><code>QualifiedBracketOperation</code> qualifier</li>
          <li><code>StructOperation</code> qualifier</li>
          <li>Expect qualified <code>unquote</code> to only have invalid results.</li>
          <li>Don't mark invalid only results for first chained function call.<br>
            Don't report <code>unquote(schema).__schema__(:source)</code></li>
          <li>Don't mark invalid only results for chained function calls.<br>
            Don't report <code>Mix.shell().yes?("Are you sure you want to drop the database for repo #{inspect repo}?") </code></li>
          <li>Don't mark invalid resolved function of call output</li>
          <li>Don't mark invalid resolved keys or fields of call output</li>
          <li>Don't mark invalid resolved function call on keys or fields</li>
          <li>Don't mark parentheses calls on variables if the call does not resolve.<br>
            Can't find exact valid resolves on variables yet.</li>
          <li>Don't mark keys or fields on the output of a function call.</li>
        </ul>
      </li>
      <li>Fix some bugs with <code>Ecto.Query</code> calls.
        <ul>
          <li>Add missing <code>state.put(Query.Call, call)</code> for <code>join/3-4</code> <code>executeOnIn</code>.</li>
          <li>Walk the operands of <code>|&gt;</code> in <code>select</code> expressions.</li>
          <li>Resolve pinned variables as normal instead of as reference variables for Ecto.Query calls.</li>
          <li>Don't walk keywords that cannot declare reference variables.
            <ul>
              <li><code>hints</code></li>
              <li><code>lock</code></li>
              <li><code>intersect</code></li>
              <li><code>intersect_all</code></li>
              <li><code>except</code></li>
              <li><code>except_all</code></li>
              <li><code>union</code></li>
              <li><code>union_all</code></li>
              <li><code>prefix</code></li>
              <li><code>preload</code></li>
              <li><code>offset</code></li>
              <li><code>windows</code></li>
              <li><code>limit</code></li>
            </ul>
          </li>
          <li>Don't treat signature for call definition as use of Ecto macro</li>
        </ul>
      </li>
      <li>Don't generate references to aliases, functions, or types that don't have declarations
        <ul>
          <li><code>assoc/2</code> in <code>join: .. in assoc(_, _)</code> in a no parentheses <code>from</code> call</li>
          <li><code>var</code> in type restrictions<br>
            Related to <span class="reference"><svg class="octicon octicon-issue-closed closed mr-1" title="Closed" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M11.28 6.78a.75.75 0 00-1.06-1.06L7.25 8.69 5.78 7.22a.75.75 0 00-1.06 1.06l2 2a.75.75 0 001.06 0l3.5-3.5z"></path><path fill-rule="evenodd" d="M16 8A8 8 0 110 8a8 8 0 0116 0zm-1.5 0a6.5 6.5 0 11-13 0 6.5 6.5 0 0113 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1014241137" data-permission-text="Title is private" data-url="https://github.com/elixir-ecto/ecto/issues/3756" data-hovercard-type="issue" data-hovercard-url="/elixir-ecto/ecto/issues/3756/hovercard" href="https://github.com/elixir-ecto/ecto/issues/3756">Can't find type for var used in c:Ecto.Adapter.checkout/3<span class="issue-shorthand">&nbsp;elixir-ecto/ecto#3756</span></a></span></li>
          <li><code>BitString</code><br>
            <code>BitString</code> is recognized in <code>defimpl ..., for: BitString</code> to define protocol implementations for <code>&lt;&lt;..&gt;&gt;</code>, but the <code>BitString</code> module itself does not exist, so can't be resolved.</li>
        </ul>
      </li>
      <li>Error reporting
        <ul>
          <li>Ignore <code>at com.intellij.openapi.diagnostic.Logger</code> when calculating location for error report titles</li>
          <li>Improve error report format sent to GitHub</li>
          <li>Fix the <code>event</code> <code>message</code> not being included, which meant that the excerpt wasn't included, so no reproducibility or element class was available.</li>
          <li>Filter stacktrace to stop at last line from the plugin to limit their size and improve chance of URL being short enough for GitHub.</li>
          <li>Don't include "What I was doing" section unless user actually fills in the additional information in the UI form.<br>
            I'm sick of seeing the issue tracker full of "I don't know what I was doing", which is the default text when no additional info is given in the UI form.</li>
          <li>Set title to the message at start of exception and first <code>at</code> that isn't from the <code>errorreport.Logger</code> instead of <code>[auto-generated]</code> as this is the pattern I follow when renaming manually.</li>
        </ul>
      </li>
      <li>Handle <code>alias __MODULE__.{...}</code> in prependQualifier<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1028941524" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2153" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2153/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2153">Unable to move files if the file contains <code>alias __MODULE__.{Something}</code><span class="issue-shorthand">&nbsp;#2153</span></a></span></li>
      <li>Log error, but don't fail with TODO() for unknown strippedQualifier or null qualifier<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1028941524" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2153" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2153/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2153">Unable to move files if the file contains <code>alias __MODULE__.{Something}</code><span class="issue-shorthand">&nbsp;#2153</span></a></span></li>
      <li>Go To Declaration for captures
        <ul>
          <li>
            <p>Don't allow name to be acceptable named parent in <code>&amp;name/arity</code>.<br>
              Resolves <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="186325149" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/488" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/488/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/488">Go To Declaration for name/arity captures<span class="issue-shorthand">&nbsp;#488</span></a></span><br>
              Allows Go To Declaration on <code>name</code> and not just on <code>/arity</code>.</p>
          </li>
          <li>
            <p>Don't allow <code>Mod.name</code> to be acceptable named parent in <code>&amp;Mod.name/arity</code>.<br>
              Resolves <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="186325149" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/488" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/488/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/488">Go To Declaration for name/arity captures<span class="issue-shorthand">&nbsp;#488</span></a></span><br>
              Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1005022918" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2101" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2101/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2101">Go to declaration do not work in <code>&amp;function_name/arity</code> anonymous functions.<span class="issue-shorthand">&nbsp;#2101</span></a></span></p>
            <p>Allows Go To Declaration on <code>name</code> and not just on <code>/arity</code>.</p>
          </li>
          <li>
            <p>Resolve <code>&amp;name/arity</code> and <code>&amp;Mod.name/arity</code> using same code as callables.<br>
              Fixes resolving &amp;Mod.name.arity and ensures that special handling for weird definitions for callables also apply to captures.</p>
          </li>
        </ul>
      </li>
      <li>Resolve <code>__MODULE__</code> in <code>quote</code> to <code>defmacro __MODULE__</code> in <code>Kernel.SpecialForms</code></li>
      <li>Performance
        <ul>
          <li>
            <p>Fix String.Unicode decompiled being PlainText instead of Elixir<br>
              <code>String.Unicode</code> when decompiled using all information from <code>DbgI</code> was 161,171 lines long, which made the JetBrains API treat it as plain text instead of Elixir.  Being that long also made it freeze the UI while being decompiled.</p>
            <p>Now, don't even attempt to use the <code>DbgI</code> if the function has more than 10 clauses.</p>
          </li>
        </ul>
      </li>
      <li>Fix resolving type specs
        <ul>
          <li>
            <p>Find <code>ancestorTypeSpec</code> for qualified type used in parentheses in anonymous function type in an alternation</p>
            <div class="snippet-clipboard-content position-relative overflow-auto"><pre><code>@type run :: ((Ecto.Repo.t, changes) -&gt; {:ok | :error, any}) | {module, atom, [any]}
</code></pre><div class="zeroclipboard-container position-absolute right-0 top-0">
              <clipboard-copy aria-label="Copy" class="ClipboardButton btn js-clipboard-copy m-2 p-0 tooltipped-no-delay" data-copy-feedback="Copied!" data-tooltip-direction="w" value="@type run :: ((Ecto.Repo.t, changes) -> {:ok | :error, any}) | {module, atom, [any]}
" tabindex="0" role="button">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon m-2">
                  <path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-text-success d-none m-2">
                  <path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path>
                </svg>
              </clipboard-copy>
            </div></div>
          </li>
          <li>
            <p>Resolve type parameters used in inline anonymous function types</p>
          </li>
          <li>
            <p>Resolve callback heads to themselves when they have type restrictions using when</p>
          </li>
        </ul>
      </li>
      <li>putInitialVisitedElement in variable.Variants<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="935316300" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2002" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2002/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2002">java.lang.Throwable: VISITED_ELEMENT_SET is null.  putInitialVisitedElement was not called<span class="issue-shorthand">&nbsp;#2002</span></a></span></li>
      <li>Walk <code>defdelegate</code>s when walking <code>import</code>s<br>
        Fixes resolving <code>config</code> from <code>use Mix.Config</code> as it delegates to <code>Config</code></li>
      <li>Resolve variables used in <code>match?</code> guards to pattern declaration<br>
        Resolves <code>on_delete</code> in <code>match?(%{on_delete: on_delete} when on_delete != :nothing, reflection)</code></li>
      <li>Implementations and Protocols
        <ul>
          <li>Fix calculating definition for stubs of defimpl with <code>for:</code><br>
            There was no clause for defimpl being arity 3, which is the case when there is the (1) protocol (2) <code>for:</code> and (3) <code>do</code> block.  Not having a definition meant that the <code>defimpl protocol, for: struct do</code> would be in AllName index, but not ModularName.</li>
          <li>Get name of enclosing modular for defimpl without <code>for:</code></li>
        </ul>
      </li>
      <li>Store if stubs are guards</li>
      <li>Decompiler</li>
      <li>Surround <code>case</code> statements with parentheses when used in <code>cond</code> clause conditions</li>
      <li>Convert OtpErlangString to OtpErlangList for tuple and call argument lists</li>
      <li>Escape ESC character as \e</li>
      <li>Handle Clause arguments being OtpErlangString</li>
      <li>Escape Erlang char \ as \</li>
      <li>Escape fn Erlang variable</li>
      <li>Handle tuple elements being an OtpErlangString</li>
      <li>Add missing <code>.</code> after callee when it is a module or fn</li>
      <li>Protect from Macro.toString(macro) StackOverflowError when decompiling body of function clauses</li>
      <li>Don't print function names as atoms in captures</li>
      <li>Escape <code>\x</code> to <code>\\x</code> in OtpErlangStr</li>
      <li>Fix rewrite of :erlang calls</li>
      <li>Surround type unions with parentheses<br>
        Prevents parsing problems with unions in guard (when) clauses</li>
      <li>Process imports for calls<br>
        Imports were previously only processed inside of Modules and not in general, which means that imports in the file were not processed, which is needed for <code>association.ex</code> in Ecto.</li>
      <li>Classify ..// as OTHER instead of NOT_CALLABLE, so that it is escaped as a key.</li>
      <li>Fix Macro.ifCaptureModuleNameArity</li>
      <li>Resolve variable to parameter in <code>%parameter{}</code> patterns for struct names</li>
      <li><code>Unquote.treeWalkUpUnquoted</code> through tuples</li>
      <li><code>Quote.treeWalkUp</code> through <code>case</code></li>
      <li>Stop searching on numerical index in binding</li>
      <li>Stop searching if atom in wrong place in binding<br>
        Stops invalid binding test from erroring when resolving it.</li>
      <li>Turn off <code>tailrec</code> because it doesn't work correctly for <code>ElixirAccessExpression</code></li>
      <li>Stop searching for qualifier when <code>ElixirUnqualifiedNoParenthesesManyArgumentsCall</code>.</li>
      <li>
        Stop highlighting types when <code>unquote_splicing/1</code> is reached.<br>
        <code>unquote_splicing</code> is being used to splat arguments or fields of a struct into the type.  The
        arguments to <code>unquote_splicing</code> are normal calls or variables, not types.
      </li>
      <li>Implement <code>call_definition_clause.Variants#executeOnCallback</code></li>
      <li><code>CallDefinitionClause.time/1</code>
        <ul dir="auto">
          <li>Mark guards as runtime.</li>
          <li>Mark anything unknown as runtime too.</li>
          <li>Log unknown calls.</li>
        </ul>
      </li>
      <li>
        Check if <code>Call</code> <code>isValid</code> before using <code>containingFile</code> for
        <code>locationString</code>.
      </li>
      <li>Check if <code>project</code> is not dumb in <code>nameArityInAnyModule</code>.</li>
      <li>
        Take <code>resolveInScope</code> only if at least one valid<br>
        Checking only for an empty collection allowed any prefixes in the scope to override exact matches in anywhere
        indexed, which meant that <code>Ecto</code> in <code>defmodule Ecto.Adapter do</code> resolved to itself instead
        of the exact <code>defmodule Ecto do</code>.
      </li>
      <li>
        When regenerating the parser, <code>ElixirVisitor</code> is also regenerated.  When it was regenerated it lost
        the bug fix for <code>#visitLiteralSigileLine</code> calling itself.  Added a regression test, so that this
        can't happen again.
      </li>
      <li>Ecto
        <ul>
          <li>Walk keyword keys as right operand of <code>in</code> in <code>from</code></li>
        </ul>
      </li>
      <li>Resolving type references
        <ul>
          <li>Walk struct operations for type parameters</li>
          <li>Check keyword values for type parameters</li>
          <li>Check operands of two operations for type parameters</li>
          <li>Stop looking for type parameters on qualified or unqualified alias</li>
        </ul>
      </li>
      <li>Decompiler
        <ul>
          <li>
            Only unquote <code>in</code> when an Erlang function, otherwise, use operators the same as Elixir for defs
            and calls.
          </li>
          <li>Fix apply Erlang arguments, so that they are inside <code>[]</code>.</li>
          <li>Quote keyword keys containing <code>-</code><br>
            Fixes decompiling of <code>Elixir.Phoenix.HTML.Tag.beam</code></li>
          <li>Use apply with escaped atom when Erlang function call is an Elixir operator</li>
        </ul>
      </li>
      <li>
        Port String.Tokenizer.tokenize for use in Identifier.inspectAsKey<br>
        I was putting off porting all of <code>Identifer.inspectAsKey</code> by adding special cases as needed, but the
        decompiler kept having bugs, so port all of it including <code>String.Tokenizer.tokenize</code>.  It will also
        work for unicode characters now too.
      </li>
      <li>Resolve calls that are unquoted values to search for quote blocks in those functions.</li>
      <li>Stop looking for qualifiers to prepend when reaching <code>=&gt;</code></li>
      <li>
        The parent argument to AccumulatorContinue.childExpressionsFoldWhile should be this and not parent<br>
        When converting to an extension function I left <code>parent</code> in place because the argument is called
        <code>parent</code>, but since it is an extension function that value because <code>this.parent</code> when it
        really should have been <code>this</code>.  Using <code>this.parent</code> meant it would ask for the parent's
        children and keep looping back to <code>this</code>.
      </li>
      <li>
        Don't use <code>tailrec</code> in function with any body-recursion.<br>
        It causes issues with <code>ElixirAccessExpression</code> recursion sometimes.
      </li>
      <li>Implement completion for functions declared with <code>defdelegate</code>.</li>
      <li>Fix <code>LookupElementPresentation.putItemPresentation</code> <code>addTailText</code>.<br>
        Only append suffix of <code>presentableText</code> if it is prefixed by <code>itemText</code>.</li>
      <li>Decompiler
        <ul dir="auto">
          <li>Elixir
            <ul dir="auto">
              <li>Decompile local function calls in Elixir DbgI using inspectAsFunction<br>
                While remote calls used <code>inspectAsFunction</code>, local calls just used the <code>atomValue</code>,  which meant names that needed to be unquoted weren't and caused parsing errors.</li>
            </ul>
          </li>
          <li>Erlang Abst
            <ul dir="auto">
              <li>Decompile Erlang Abst string with OtpErlangList as strings with non-ASCII codepoints<br>
                Fixes unknown string format in <code>idna.beam</code></li>
              <li>Always group for comprehensions in sequence even if there is only 1 element<br>
                Some forms of <code>for</code> comprehensions cannot be used as the sole argument of a call unless surrounded by parentheses, so always add those parentheses.</li>
              <li>Decompile Erlang Abst record empty record fields as <code>[]</code> for updates</li>
              <li>Decompile Erlang Abst <code>left xor right</code> as <code>:erlang.xor(left, right)</code><br>
                Elixir does not have a logical xor infix operator, so have to decompile as normal function call</li>
              <li>Decompile Erlang Abst named anonymous function as a macro<br>
                Named anonymous functions are support in Erlang, but not Elixir, so fake it as a macro when decompiling.</li>
              <li>Add builtin-types for Erlang Abst
                <ul dir="auto">
                  <li><code>bitstring</code></li>
                  <li><code>float</code></li>
                  <li><code>nonempty_improper_list</code></li>
                  <li><code>nonempty_maybe_improper_list</code></li>
                </ul>
              </li>
              <li>Decompile tagged atoms and other complex expression as function name in Abst capture</li>
              <li>Decompile Erlang Abst <code>float</code></li>
              <li>Decompile Erlang Abst <code>begin</code> blocks as parenthesized groups separated by ;</li>
              <li>Decompile empty OtpErlangList as "" in Erlang Abst <code>string</code></li>
              <li>Track if decompiled Erlang Abst contains do blocks so that they can be surrounded by parentheses when necessary</li>
              <li>Fix decompiling Erlang Abst <code>record_index</code> when record name needs to be unquoted</li>
              <li>Decompile <code>map</code> updates in Erlang Abst</li>
              <li>Erlang Abst Function capture names are OtpErlangAtom and not tagged Atoms</li>
              <li>Inspect local function names as atoms instead of as functions when apply/3 is used for operations and unquoted in Erlang Abst<br>
                Stops <code>:unquote(:"NAME")</code> from happening</li>
              <li>Surround anonymous function definitions that are called immediately with parentheses and call arguments with .( in Erlang Abst</li>
              <li>Decompile <code>field_type</code> in Erlang Abst<br>
                Fixes decompiling <code>hipe_icode_call_elim.beam</code></li>
              <li>Inspect type name usages as local functions to ensure invalid names are unquoted</li>
              <li>Inspect type names as local functions to ensure invalid names are unquoted</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>References
        <ul dir="auto">
          <li>Stop looking for qualifiers to prepend when exiting interpolation</li>
          <li>Don't safeMultiResolve null call.reference in resolvesToModularName</li>
        </ul>
      </li>
      <li>Types
        <ul dir="auto">
          <li>Fix highlighting types declared with unquote and no secondary parentheses</li>
        </ul>
      </li>
      <li>Performance
        <ul dir="auto">
          <li>Don't error if a private function mirror cannot be found<br>
            Private functions are not decompiled if there are too many public functions.</li>
          <li>Fix CallDefinitionImpl.isExported<br>
            Used to be hard-coded to return <code>true</code>, but this pre-dated decompiling private functions.  Now with decompiling private functions, isExported needs to defer to the <code>Definition</code> and count as unexported if a private function, macro, or guard.</li>
        </ul>
      </li>
      <li>
        Walk map constructin arguments, associatons, and variables when resolving type parameters.
      </li>
      <li>Don't use <code>PluginId.findId</code> that doesn't exist in 2021.1.X</li>
    </ul>
  </li>
</ul>
<h1>v11.13.0</h1>
<ul>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>Remove bintray repositories.</li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Update build to IntelliJ IDEA 2021.2.</li>
      <li>Upgrade to Gradle 7.1.1.</li>
      <li>Expand compatibility range to 2021.1.2-2021.2.</li>
    </ul>
  </li>
</ul>
<h1>v11.12.0</h1>
<ul>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>
        <p>Find <code>Dep</code>s in function calls in the <code>deps()</code> list.</p>
      </li>
      <li>
        <p><code>Dep.putPath</code> from a variable.</p>
      </li>
      <li>
        <p>Treat <code>Memoize</code> <code>defmemo</code> as <code>def</code> and <code>defmemop</code> as <code>defp</code>.</p>
      </li>
      <li>
        <p>Resolve <code>exception/1</code> and <code>message/1</code> to <code>defexception</code>.</p>
      </li>
      <li>
        <p>Resolve to callbacks when searching in any module.</p>
      </li>
      <li>
        <p>Support arity intervals for unquote_splicing in parameters</p>
        <p>Functions defined with unquote_splicing, such as <code>Ecto.Schema.__schema/2</code>:</p>
        <div class="highlight highlight-source-elixir position-relative"><pre><span class="pl-k">for</span> clauses <span class="pl-k">&lt;-</span> <span class="pl-en">Ecto</span>.<span class="pl-en">Schema</span>.<span class="pl-en">__schema__</span>(fields, field_sources, assocs, embeds),
    {args, body} <span class="pl-k">&lt;-</span> clauses <span class="pl-k">do</span>
  <span class="pl-k">def</span> <span class="pl-en">__schema__</span>(<span class="pl-en">unquote_splicing</span>(args)), <span class="pl-c1">do:</span> <span class="pl-en">unquote</span>(body)
<span class="pl-k">end</span></pre><div class="zeroclipboard-container position-absolute right-0 top-0">
          <clipboard-copy aria-label="Copy" class="ClipboardButton btn js-clipboard-copy m-2 p-0 tooltipped-no-delay" data-copy-feedback="Copied!" data-tooltip-direction="w" value="for clauses <- Ecto.Schema.__schema__(fields, field_sources, assocs, embeds),
    {args, body} <- clauses do
  def __schema__(unquote_splicing(args)), do: unquote(body)
end
" tabindex="0" role="button">
            <svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" data-view-component="true" height="16" width="16" class="octicon octicon-clippy js-clipboard-clippy-icon m-2">
              <path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path>
            </svg>
            <svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" data-view-component="true" height="16" width="16" class="octicon octicon-check js-clipboard-check-icon color-text-success d-none m-2">
              <path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path>
            </svg>
          </clipboard-copy>
        </div></div>
        <p>Need to have their arity not be the number of PsiElements in the parentheses.  Any call to <code>unquote_splicing(...)</code> can end up have 0 to infinite parameters, so it means when one is saw, the range of <code>minimum...maximum</code> should change to an open interval of <code>minimum...</code>.  This required changing <code>IntRange resolvedFinalArityChange()</code> to <code>ArityInterval resolvedFinalArityInterval()</code> on all <code>Call</code>s, which was a large change.  It also meant changing a lot of ArityRange types to ArityInterval, and NameArityRange to NameArityInterval, which influenced the variable names.</p>
        <p>Since all Calls support ArityIntervals now and not just special forms and Ecto DSLs, exportArity is changed to always state the ResolveState, so that the special form changes can be integrated for all callers.</p>
        <p>The actual implementation of CallImpl.resolvedFinalArityRange is changes to fold over the ArityInterval:</p>
        <ul>
          <li>Normal arguments increase the minimum and maximum.</li>
          <li>Default arguments increase only the maximum.</li>
          <li>unquote_splicing changes the maximum to null to indicate the interval is half open.</li>
        </ul>
      </li>
      <li>Convert MissingSDK errors for Dialyzer into Notifications.</li>
      <li>
        Log element in psi.scope.Type instead of using <code>TODO()</code><br>
        Error will still be reported, but there will be enough information to triage and since <code>true</code> is
        returned now it won't stop the type resolving from working.
      </li>
      <li>
        Add missing mix deps options to non-path influencing list:
        <ul>
          <li>env</li>
          <li>manager</li>
          <li>repo</li>
          <li>sparse</li>
          <li>submodules</li>
          <li>system_env</li>
        </ul>
      </li>
      <li>
        Fix Fix incorrect <code>OuterElementType</code> in <code>eex.lexer.TemplateData</code>.<br/>
        The <code>EEX</code> <code>IElementType</code> needs to use <code>OuterLanguageElementType</code> instead of the
        direct <code>eex.psi.TokenType</code>.
      </li>
      <li>
        Run <code>QualifiedAlias#text</code> in <code>runReadAction</code> for <code>QualifiedAlias#name</code>
      </li>
      <li>
        Return <code>null</code> <code>Chunk</code> instead of throwing <code>IOException</code> when read incomplete.<br>
        Incomplete reads happen often due to incomplete writes to the file system being read in. As such, they shouldn't
        generate error reports and instead should be silently ignored.
      </li>
      <li>
        Implement <code>beam.FileEditor#getFile</code> to fix <code>DeprecatedMethodException</code> as the default
        implementation is now deprecated and requires an explicit implementation.
      </li>
      <li>
        Use <code>TabbedPaneWrapper.AsJBTabs</code> instead of <code>JBTabbedPane</code> for "BEAM Chunks" tabs.<br>
        I'm not sure why <code>JBTabbedPane</code> stopped showing its labels sometime in the 2020.X IDE version series,
        but by debugging when "BEAM Chunks" name was retrieved I found that the bottom tabs used
        <code>TabbedPaneWrapper.asJBTabs</code>.  Using that, the labels reappeared.
      </li>
      <li>
        Don't require Alias qualifier to be a <code>PsiNamedElement</code><br>
        It can be an <code>ElixirAtom</code> and getting the reference will still work.
      </li>
      <li><code>Any.isDecompiled</code> for <code>CallDefinitionHead</code>.</li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Only descend into modular children of modular for Module scope.  Prevents recursion loops on use calls.</li>
      <li>Don't search for unquoted variable value variable is value for <code>do:</code>.</li>
      <li>Protect from <code>IndexNotReady</code> in <code>resolver.Module.multiResolveProject</code>.</li>
      <li>Stop walking unquoted variable that resolves to a parameter.</li>
      <li>
        Walk case in <code>__using__</code> to find quote in any clause.  Fixes resolving test macro from
        <code>use PowerAssert</code>
      </li>
      <li>
        Resolve functions declared in <code>quote</code>'s scope when <code>block</code> injected with
        <code>unquote(block)</code>.<br>
        Fixes resolving <code>field</code>, <code>timestamps</code>, and <code>index</code> in <code>schema</code> for
        <code>use Yacto.Schema</code> as it makes the <code>block</code> see the <code>import Yacto.Schema</code> above
        <code>unquote(block)</code> in the <code>quote</code> in <code>schema(..., do: block)</code>.
      </li>
    </ul>
  </li>
</ul>
</body>
</html>
