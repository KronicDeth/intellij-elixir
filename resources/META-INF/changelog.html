<html>
<body>
<h1>v12.0.0</h1>
<ul>
  <li>
    <p>Breaking Changes</p>
    <ul>
      <li>Drop support for Elixir &lt;= 1.6.<br>
        Continuing support for Elixir &lt;= 1.6 required special handling of the language level to support differences
        in precedence and operators.  Removing the language level tracking allows dropping the <code>Level</code> and
        <code>FilePropertyPusher</code> classes and all their usages, including in the parser grammar and the special
        <code>ifVersion</code> external rule.  It also eliminates the need for tests to setup the SDK since it was only
        needed to get the appropriate Level.  This makes the tests run in 45 seconds instead of 7 minutes.
      </li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Resolve more calls and bindings in <code>Ecto.Query</code> calls
        <ul>
          <li>Resolve bindings in <code>Ecto.Query.lock/3</code></li>
          <li>Resolve bindings in <code>Ecto.Query.windows/3</code></li>
          <li>Walk <code>preload</code> binding and expression</li>
          <li>Resolve in <code>update</code> for Ecto.Query</li>
          <li>Resolve <code>fragment</code> in <code>with_cte</code></li>
          <li>Resolve <code>binding</code> and <code>expr</code> in <code>Ecto.Query.dynamic/1-2</code></li>
          <li>
            Resolve <code>field</code> in <code>join(..., on: field(..., ...) ...)</code><br>
            For <code>join/5</code>, descend into the options to look for <code>on: value</code> and then walk
            <code>value</code> the same as the value to <code>having</code> or <code>where</code> in selects since
            they're all boolean conditions.
          </li>
          <li>Extract <code>ecto.query.Nested</code></li>
          <li>Resolve <code>Ecto.Query.WindowAPI</code> functions</li>
          <li>
            <p>Resolve reference variable src in <code>join(query, ..., [{src, counter}], ..., ...)</code><br>
              Tuple lists in join have two forms:</p>
            <ol>
              <li><code>{^assoc, a}</code></li>
              <li><code>{src, counter}</code></li>
            </ol>
            <p>
              The pinned association form was already handled because the second element was checked for a declaration,
              but the first element was not, so <code>src</code> in (2) could not be resolved.
            </p>
          </li>
          <li><code>from([..] in ...)</code></li>
          <li>Treat <code>or_having</code> the same as <code>having</code></li>
          <li>Treat <code>or_where</code> the same as <code>where</code></li>
          <li>Treat <code>having:</code> the same as <code>where:</code> in <code>from</code></li>
          <li>
            Treat <code>select_merge</code> the same as <code>select</code> for resolving <code>Ecto.Query.API</code>.
          </li>
          <li><code>from(..., [elements])</code></li>
          <li>Resolve Ecto reference variables in <code>left in ...</code></li>
        </ul>
      </li>
      <li><code>ModuleWalker</code> and <code>NameArityRangeWalker</code><br>
        Reduce code by abstracting common pattern for walking library APIs.</li>
      <li><code>ExUnit</code>
        <ul>
          <li>Find modules declared in <code>test</code>s.</li>
          <li>Resolve call definitions inside <code>describe</code> blocks.</li>
          <li>Resolve variables in <code>assert_receive</code> and <code>assert_received</code>.</li>
          <li>Resolve <code>alias</code> to modules defined inside the enclosing <code>describe</code> block.</li>
          <li>Walk <code>assert</code> expression for variable declarations
            <ul>
              <li>Check for earlier bindings of variables in right operand of <code>=</code> in <code>assert</code>.</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve <code>require</code> <code>as:</code> arguments as Aliases</li>
      <li>Decompiler
        <ul>
          <li>Erlang
            <ul>
              <li>Decompile private Erlang functions</li>
              <li>Decompile specs from Erlang DbgI</li>
              <li>Decompile function bodies from Erlang DbgI
                <ul>
                  <li>Escape "in" when an Erlang Var in type</li>
                </ul>
              </li>
              <li>Decompile types from Erlang DbgI<br>
                Fixes #2017</li>
            </ul>
          </li>
          <li>Decompile Elixir function bodies using DbgI
            <ul>
              <li>:erlang./(a, b) -&gt; a / b</li>
              <li>:erlang.*(a, b) -&gt; a * b</li>
              <li>Convert :erlang.==(a,b) to a == b</li>
              <li>Rewrite case to <code>and</code> when there is a badbool error too</li>
              <li>Decompile %{<strong>struct</strong>: name, ...} as %name{...}</li>
              <li>Rewrite more :erlang functions to Elixir</li>
              <li>Rewrite case to ||</li>
              <li>Rewrite <code>case expr1 do pat1 -&gt; true; _ -&gt; false; end</code> to <code>match?(pat1, expr1)</code></li>
              <li>Rewrite <code>if var do false else true</code> to <code>!var</code></li>
              <li>Rewrite case to or</li>
              <li>Rewrite case to and</li>
              <li>Rewrite :erlang.error(E.exception(M)) to raise E, M</li>
              <li>Rewrite case statements to if</li>
              <li>Rewrite case statements to &amp;&amp;</li>
              <li>Indent all lines of spec macro string in case it is multiple <a class="user-mention" data-hovercard-type="organization" data-hovercard-url="/orgs/SPEC/hovercard" href="https://github.com/SPEC">@SPEC</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve module attributes defined outside the immediate modular lexical scope
        <ul>
          <li>
            <p>Resolve module attributes registered in <code>elixir_module.erl</code> to decompiled source</p>
            <ul>
              <li>after_compile</li>
              <li>before_compile</li>
              <li>behaviour</li>
              <li>compile</li>
              <li>derive</li>
              <li>dialyzer</li>
              <li>external_resource</li>
              <li>on_definition</li>
            </ul>
          </li>
          <li>
            <p>Index module attributes<br>
              Use the index to resolve module attributes when it can't be found directly by tree walking.</p>
            <ul>
              <li>Defined with <code>Module.put_attribute/3</code></li>
              <li>Defined with <code>Module.register_attribute/3</code></li>
              <li>Defined in <code>quote</code> blocks</li>
            </ul>
          </li>
        </ul>
      </li>
      <li>Resolve variables to variables in any <code>quote</code> blocks<br>
        If a variable can't be resolved in the scope, try resolving it to any variable declared at the top-level of a <code>quote</code> block.  This helps with certain patterns of <code>quote</code> blocks used in Ecto where a variable's declaration and usage are not in the same <code>quote</code> block.</li>
      <li>Simplify CallDefinitionClause resolver for modulars<br>
        Due to the addition of skipping if the entrance is a child call, the check for only following siblings is no longer needed.  Additionally, that check caused a bug because the <code>ElixirStabBody</code> skipped call definitions because they were new scopes.</li>
      <li>Resolve functions declared with <code>Mix.Generator.embed_template</code> and <code>embed_text</code>.<br>
        Also, new system for tracking resolves paths - <code>import</code>s, <code>defdelegate</code>, and <code>use</code> calls are added to the resolve results after the preferred elements are chosen for source in the same module.  This prevents only the <code>import</code> showing because the actual declaration is in another module or the SDK.</li>
      <li>Record a call as visited in its <code>treeWalkUp</code> instead of requiring the caller to do it in the pass <code>ResolveState</code>
        <ul>
          <li>Record <code>quoteCall</code> as visited in <code>QuoteMacro.treeWalkUp</code></li>
          <li>Record <code>unquoteCall</code> as visited in <code>Unquote.treeWalkUp</code></li>
          <li>Record <code>unlessCall</code> as visited in <code>Unless.treeWalkUp</code></li>
          <li>Record <code>ifCall</code> as visited in <code>If.treeWalkUp</code></li>
          <li>Record <code>importCall</code> as visited in <code>Import.treeWalkUp</code></li>
          <li>Record <code>useCall</code> as visited in <code>Use.treeWalkUp</code></li>
        </ul>
      </li>
      <li>More macro specialized in Structure View
        <ul>
          <li><code>test</code></li>
          <li><code>describe</code></li>
        </ul>
      </li>
      <li>Resolve <code>Qualifer.unquote(variable)(...)</code> to any definition with correct arity in <code>Qualifier</code>.</li>
      <li>Only calculate <code>element.resolvedFinalArity</code> once in <code>resolvedQualified</code></li>
      <li>Implementations and Protocols
        <ul>
          <li>Redo icons</li>
          <li>Implementations Go To Protocol line markers</li>
          <li>Go to Super for calls to <code>defimpl</code> function/macro<br>
            Goes to corresponding name/arity in the <code>defprotocol</code> that the <code>defimpl</code> implements.</li>
          <li>Go to implementations line marker from defprotocol def</li>
          <li>Go to implementations line marker from defprotocol</li>
          <li>Go To Implementation from individual functions in defimpl</li>
          <li>Go To Implementation from defimpl Alias</li>
          <li>Resolve protocol function to <code>def</code> in defprotocol</li>
          <li>Resolve defp inside of defimpl<br>
            Process declarations inside of implementation the same as modules.</li>
        </ul>
      </li>
      <li>Stop <code>prependQualifiers</code> at top of file</li>
      <li>Walk the false and true (else) branch of unless in Modules or Quote</li>
      <li>Walk the true and false (else) branch of if in Modules or Quote</li>
      <li>Regression test for <a href="https://github.com/KronicDeth/intellij-elixir/issues/2198">#2198</a></li>
      <li>Use callbacks as completions for calls.</li>
    </ul>
  </li>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>Alternative function clause for <code>put_event</code> with <code>suite_finished</code></li>
      <li>StackOverflow fixes
        <ul>
          <li>
            getElementDescription(ElixirAtom, ElementDescriptionLocation)<br>
            Override getElementDescription for atoms to prevent StackOverflow while looking for a provider.
          </li>
          <li>
            Don't descend into either branch of <code>if</code> or <code>unless</code> if entrance in either branch when resolving calls.<br>
            If the definition were in one of the branch, it would already have been found on processing previous siblings in the <code>ElixirStabBody</code>.
          </li>
          <li>
            Treat child of modulars as being at the same level if nested in <code>if</code> or <code>unless</code><br>
            Prevents <code>test</code> in <code>if</code> in <code>supervisor_test.exs</code> in <code>ecto</code> from stack overflowing.
          </li>
          <li>
            Fix StackOverflow when looking for earlier bindings in parameters.
          </li>
          <li>
            <p>Don't check following siblings of modulars if entrance is a direct child</p>
            <p>Prevent StackOverflow when trying to resolve embed_template when more than one appears in the same module.</p>
            <p>In general, if the entrance is a child of modular then it can only be defined by a previous sibling, usually an <code>import</code> or <code>use</code>, but if the entrance is descendant of a child, then it child then it may be a call to a function or macro defined in the modular to following siblings of the entrance ancestor child needs to be checked if the entrance is a forward-call to a later declared function or macro.</p>
          </li>
          <li>
            Fix StackOverflowError in ifErlangRewriteTo<br>
            Don't rewriter :erlang.* to a different :erlang.*
          </li>
        </ul>
      </li>
      <li>Adjust nameArityInterval in nameArityInAnyModule<br>
        Ensures that <code>fragment/1..</code> used in a <code>quote</code> can resolve to one in <code>Ecto.Query.API</code>.</li>
      <li>Resolve variable that are the only child of <code>quote</code><br>
        Ecto loves doing <code>quote do: query</code> or other variable names in the code and tests, so record those as declarations to resolve as invalid results.</li>
      <li>Find enclosing macro call when keyword <code>do:</code> is surrounded by parentheses<br>
        Previously, only <code>quote do: variable</code> would work, but now <code>quote(do: variable)</code> also works to find the <code>quote</code> call.</li>
      <li>Don't mark fields and keys that are not expected to be resolvable yet as unresolvable in Elixir References inspection.
        <ul>
          <li><code>QualifiedBracketOperation</code> qualifier</li>
          <li><code>StructOperation</code> qualifier</li>
          <li>Expect qualified <code>unquote</code> to only have invalid results.</li>
          <li>Don't mark invalid only results for first chained function call.<br>
            Don't report <code>unquote(schema).__schema__(:source)</code></li>
          <li>Don't mark invalid only results for chained function calls.<br>
            Don't report <code>Mix.shell().yes?("Are you sure you want to drop the database for repo #{inspect repo}?") </code></li>
          <li>Don't mark invalid resolved function of call output</li>
          <li>Don't mark invalid resolved keys or fields of call output</li>
          <li>Don't mark invalid resolved function call on keys or fields</li>
          <li>Don't mark parentheses calls on variables if the call does not resolve.<br>
            Can't find exact valid resolves on variables yet.</li>
          <li>Don't mark keys or fields on the output of a function call.</li>
        </ul>
      </li>
      <li>Fix some bugs with <code>Ecto.Query</code> calls.
        <ul>
          <li>Add missing <code>state.put(Query.Call, call)</code> for <code>join/3-4</code> <code>executeOnIn</code>.</li>
          <li>Walk the operands of <code>|&gt;</code> in <code>select</code> expressions.</li>
          <li>Resolve pinned variables as normal instead of as reference variables for Ecto.Query calls.</li>
          <li>Don't walk keywords that cannot declare reference variables.
            <ul>
              <li><code>hints</code></li>
              <li><code>lock</code></li>
              <li><code>intersect</code></li>
              <li><code>intersect_all</code></li>
              <li><code>except</code></li>
              <li><code>except_all</code></li>
              <li><code>union</code></li>
              <li><code>union_all</code></li>
              <li><code>prefix</code></li>
              <li><code>preload</code></li>
              <li><code>offset</code></li>
              <li><code>windows</code></li>
              <li><code>limit</code></li>
            </ul>
          </li>
          <li>Don't treat signature for call definition as use of Ecto macro</li>
        </ul>
      </li>
      <li>Don't generate references to aliases, functions, or types that don't have declarations
        <ul>
          <li><code>assoc/2</code> in <code>join: .. in assoc(_, _)</code> in a no parentheses <code>from</code> call</li>
          <li><code>var</code> in type restrictions<br>
            Related to <span class="reference"><svg class="octicon octicon-issue-closed closed mr-1" title="Closed" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M11.28 6.78a.75.75 0 00-1.06-1.06L7.25 8.69 5.78 7.22a.75.75 0 00-1.06 1.06l2 2a.75.75 0 001.06 0l3.5-3.5z"></path><path fill-rule="evenodd" d="M16 8A8 8 0 110 8a8 8 0 0116 0zm-1.5 0a6.5 6.5 0 11-13 0 6.5 6.5 0 0113 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1014241137" data-permission-text="Title is private" data-url="https://github.com/elixir-ecto/ecto/issues/3756" data-hovercard-type="issue" data-hovercard-url="/elixir-ecto/ecto/issues/3756/hovercard" href="https://github.com/elixir-ecto/ecto/issues/3756">Can't find type for var used in c:Ecto.Adapter.checkout/3<span class="issue-shorthand">&nbsp;elixir-ecto/ecto#3756</span></a></span></li>
          <li><code>BitString</code><br>
            <code>BitString</code> is recognized in <code>defimpl ..., for: BitString</code> to define protocol implementations for <code>&lt;&lt;..&gt;&gt;</code>, but the <code>BitString</code> module itself does not exist, so can't be resolved.</li>
        </ul>
      </li>
      <li>Error reporting
        <ul>
          <li>Ignore <code>at com.intellij.openapi.diagnostic.Logger</code> when calculating location for error report titles</li>
          <li>Improve error report format sent to GitHub</li>
          <li>Fix the <code>event</code> <code>message</code> not being included, which meant that the excerpt wasn't included, so no reproducibility or element class was available.</li>
          <li>Filter stacktrace to stop at last line from the plugin to limit their size and improve chance of URL being short enough for GitHub.</li>
          <li>Don't include "What I was doing" section unless user actually fills in the additional information in the UI form.<br>
            I'm sick of seeing the issue tracker full of "I don't know what I was doing", which is the default text when no additional info is given in the UI form.</li>
          <li>Set title to the message at start of exception and first <code>at</code> that isn't from the <code>errorreport.Logger</code> instead of <code>[auto-generated]</code> as this is the pattern I follow when renaming manually.</li>
        </ul>
      </li>
      <li>Handle <code>alias __MODULE__.{...}</code> in prependQualifier<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1028941524" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2153" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2153/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2153">Unable to move files if the file contains <code>alias __MODULE__.{Something}</code><span class="issue-shorthand">&nbsp;#2153</span></a></span></li>
      <li>Log error, but don't fail with TODO() for unknown strippedQualifier or null qualifier<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1028941524" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2153" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2153/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2153">Unable to move files if the file contains <code>alias __MODULE__.{Something}</code><span class="issue-shorthand">&nbsp;#2153</span></a></span></li>
      <li>Go To Declaration for captures
        <ul>
          <li>
            <p>Don't allow name to be acceptable named parent in <code>&amp;name/arity</code>.<br>
              Resolves <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="186325149" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/488" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/488/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/488">Go To Declaration for name/arity captures<span class="issue-shorthand">&nbsp;#488</span></a></span><br>
              Allows Go To Declaration on <code>name</code> and not just on <code>/arity</code>.</p>
          </li>
          <li>
            <p>Don't allow <code>Mod.name</code> to be acceptable named parent in <code>&amp;Mod.name/arity</code>.<br>
              Resolves <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="186325149" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/488" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/488/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/488">Go To Declaration for name/arity captures<span class="issue-shorthand">&nbsp;#488</span></a></span><br>
              Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="1005022918" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2101" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2101/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2101">Go to declaration do not work in <code>&amp;function_name/arity</code> anonymous functions.<span class="issue-shorthand">&nbsp;#2101</span></a></span></p>
            <p>Allows Go To Declaration on <code>name</code> and not just on <code>/arity</code>.</p>
          </li>
          <li>
            <p>Resolve <code>&amp;name/arity</code> and <code>&amp;Mod.name/arity</code> using same code as callables.<br>
              Fixes resolving &amp;Mod.name.arity and ensures that special handling for weird definitions for callables also apply to captures.</p>
          </li>
        </ul>
      </li>
      <li>Resolve <code>__MODULE__</code> in <code>quote</code> to <code>defmacro __MODULE__</code> in <code>Kernel.SpecialForms</code></li>
      <li>Performance
        <ul>
          <li>
            <p>Fix String.Unicode decompiled being PlainText instead of Elixir<br>
              <code>String.Unicode</code> when decompiled using all information from <code>DbgI</code> was 161,171 lines long, which made the JetBrains API treat it as plain text instead of Elixir.  Being that long also made it freeze the UI while being decompiled.</p>
            <p>Now, don't even attempt to use the <code>DbgI</code> if the function has more than 10 clauses.</p>
          </li>
        </ul>
      </li>
      <li>Fix resolving type specs
        <ul>
          <li>
            <p>Find <code>ancestorTypeSpec</code> for qualified type used in parentheses in anonymous function type in an alternation</p>
            <div class="snippet-clipboard-content position-relative overflow-auto"><pre><code>@type run :: ((Ecto.Repo.t, changes) -&gt; {:ok | :error, any}) | {module, atom, [any]}
</code></pre><div class="zeroclipboard-container position-absolute right-0 top-0">
              <clipboard-copy aria-label="Copy" class="ClipboardButton btn js-clipboard-copy m-2 p-0 tooltipped-no-delay" data-copy-feedback="Copied!" data-tooltip-direction="w" value="@type run :: ((Ecto.Repo.t, changes) -> {:ok | :error, any}) | {module, atom, [any]}
" tabindex="0" role="button">
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-copy js-clipboard-copy-icon m-2">
                  <path fill-rule="evenodd" d="M0 6.75C0 5.784.784 5 1.75 5h1.5a.75.75 0 010 1.5h-1.5a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-1.5a.75.75 0 011.5 0v1.5A1.75 1.75 0 019.25 16h-7.5A1.75 1.75 0 010 14.25v-7.5z"></path><path fill-rule="evenodd" d="M5 1.75C5 .784 5.784 0 6.75 0h7.5C15.216 0 16 .784 16 1.75v7.5A1.75 1.75 0 0114.25 11h-7.5A1.75 1.75 0 015 9.25v-7.5zm1.75-.25a.25.25 0 00-.25.25v7.5c0 .138.112.25.25.25h7.5a.25.25 0 00.25-.25v-7.5a.25.25 0 00-.25-.25h-7.5z"></path>
                </svg>
                <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true" class="octicon octicon-check js-clipboard-check-icon color-text-success d-none m-2">
                  <path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path>
                </svg>
              </clipboard-copy>
            </div></div>
          </li>
          <li>
            <p>Resolve type parameters used in inline anonymous function types</p>
          </li>
          <li>
            <p>Resolve callback heads to themselves when they have type restrictions using when</p>
          </li>
        </ul>
      </li>
      <li>putInitialVisitedElement in variable.Variants<br>
        Fixes <span class="reference"><svg class="octicon octicon-issue-opened open mr-1" title="Open" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="M8 9.5a1.5 1.5 0 100-3 1.5 1.5 0 000 3z"></path><path fill-rule="evenodd" d="M8 0a8 8 0 100 16A8 8 0 008 0zM1.5 8a6.5 6.5 0 1113 0 6.5 6.5 0 01-13 0z"></path></svg><a class="issue-link js-issue-link" data-error-text="Failed to load title" data-id="935316300" data-permission-text="Title is private" data-url="https://github.com/KronicDeth/intellij-elixir/issues/2002" data-hovercard-type="issue" data-hovercard-url="/KronicDeth/intellij-elixir/issues/2002/hovercard" href="https://github.com/KronicDeth/intellij-elixir/issues/2002">java.lang.Throwable: VISITED_ELEMENT_SET is null.  putInitialVisitedElement was not called<span class="issue-shorthand">&nbsp;#2002</span></a></span></li>
      <li>Walk <code>defdelegate</code>s when walking <code>import</code>s<br>
        Fixes resolving <code>config</code> from <code>use Mix.Config</code> as it delegates to <code>Config</code></li>
      <li>Resolve variables used in <code>match?</code> guards to pattern declaration<br>
        Resolves <code>on_delete</code> in <code>match?(%{on_delete: on_delete} when on_delete != :nothing, reflection)</code></li>
      <li>Implementations and Protocols
        <ul>
          <li>Fix calculating definition for stubs of defimpl with <code>for:</code><br>
            There was no clause for defimpl being arity 3, which is the case when there is the (1) protocol (2) <code>for:</code> and (3) <code>do</code> block.  Not having a definition meant that the <code>defimpl protocol, for: struct do</code> would be in AllName index, but not ModularName.</li>
          <li>Get name of enclosing modular for defimpl without <code>for:</code></li>
        </ul>
      </li>
      <li>Store if stubs are guards</li>
      <li>Decompiler</li>
      <li>Surround <code>case</code> statements with parentheses when used in <code>cond</code> clause conditions</li>
      <li>Convert OtpErlangString to OtpErlangList for tuple and call argument lists</li>
      <li>Escape ESC character as \e</li>
      <li>Handle Clause arguments being OtpErlangString</li>
      <li>Escape Erlang char \ as \</li>
      <li>Escape fn Erlang variable</li>
      <li>Handle tuple elements being an OtpErlangString</li>
      <li>Add missing <code>.</code> after callee when it is a module or fn</li>
      <li>Protect from Macro.toString(macro) StackOverflowError when decompiling body of function clauses</li>
      <li>Don't print function names as atoms in captures</li>
      <li>Escape <code>\x</code> to <code>\\x</code> in OtpErlangStr</li>
      <li>Fix rewrite of :erlang calls</li>
      <li>Surround type unions with parentheses<br>
        Prevents parsing problems with unions in guard (when) clauses</li>
      <li>Process imports for calls<br>
        Imports were previously only processed inside of Modules and not in general, which means that imports in the file were not processed, which is needed for <code>association.ex</code> in Ecto.</li>
      <li>Classify ..// as OTHER instead of NOT_CALLABLE, so that it is escaped as a key.</li>
      <li>Fix Macro.ifCaptureModuleNameArity</li>
      <li>Resolve variable to parameter in <code>%parameter{}</code> patterns for struct names</li>
      <li><code>Unquote.treeWalkUpUnquoted</code> through tuples</li>
      <li><code>Quote.treeWalkUp</code> through <code>case</code></li>
      <li>Stop searching on numerical index in binding</li>
      <li>Stop searching if atom in wrong place in binding<br>
        Stops invalid binding test from erroring when resolving it.</li>
      <li>Turn off <code>tailrec</code> because it doesn't work correctly for <code>ElixirAccessExpression</code></li>
      <li>Stop searching for qualifier when <code>ElixirUnqualifiedNoParenthesesManyArgumentsCall</code>.</li>
      <li>
        Stop highlighting types when <code>unquote_splicing/1</code> is reached.<br>
        <code>unquote_splicing</code> is being used to splat arguments or fields of a struct into the type.  The
        arguments to <code>unquote_splicing</code> are normal calls or variables, not types.
      </li>
      <li>Implement <code>call_definition_clause.Variants#executeOnCallback</code></li>
      <li><code>CallDefinitionClause.time/1</code>
        <ul dir="auto">
          <li>Mark guards as runtime.</li>
          <li>Mark anything unknown as runtime too.</li>
          <li>Log unknown calls.</li>
        </ul>
      </li>
      <li>
        Check if <code>Call</code> <code>isValid</code> before using <code>containingFile</code> for
        <code>locationString</code>.
      </li>
      <li>Check if <code>project</code> is not dumb in <code>nameArityInAnyModule</code>.</li>
    </ul>
  </li>
</ul>
<h1>v11.13.0</h1>
<ul>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>Remove bintray repositories.</li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Update build to IntelliJ IDEA 2021.2.</li>
      <li>Upgrade to Gradle 7.1.1.</li>
      <li>Expand compatibility range to 2021.1.2-2021.2.</li>
    </ul>
  </li>
</ul>
<h1>v11.12.0</h1>
<ul>
  <li>
    <p>Bug Fixes</p>
    <ul>
      <li>
        <p>Find <code>Dep</code>s in function calls in the <code>deps()</code> list.</p>
      </li>
      <li>
        <p><code>Dep.putPath</code> from a variable.</p>
      </li>
      <li>
        <p>Treat <code>Memoize</code> <code>defmemo</code> as <code>def</code> and <code>defmemop</code> as <code>defp</code>.</p>
      </li>
      <li>
        <p>Resolve <code>exception/1</code> and <code>message/1</code> to <code>defexception</code>.</p>
      </li>
      <li>
        <p>Resolve to callbacks when searching in any module.</p>
      </li>
      <li>
        <p>Support arity intervals for unquote_splicing in parameters</p>
        <p>Functions defined with unquote_splicing, such as <code>Ecto.Schema.__schema/2</code>:</p>
        <div class="highlight highlight-source-elixir position-relative"><pre><span class="pl-k">for</span> clauses <span class="pl-k">&lt;-</span> <span class="pl-en">Ecto</span>.<span class="pl-en">Schema</span>.<span class="pl-en">__schema__</span>(fields, field_sources, assocs, embeds),
    {args, body} <span class="pl-k">&lt;-</span> clauses <span class="pl-k">do</span>
  <span class="pl-k">def</span> <span class="pl-en">__schema__</span>(<span class="pl-en">unquote_splicing</span>(args)), <span class="pl-c1">do:</span> <span class="pl-en">unquote</span>(body)
<span class="pl-k">end</span></pre><div class="zeroclipboard-container position-absolute right-0 top-0">
          <clipboard-copy aria-label="Copy" class="ClipboardButton btn js-clipboard-copy m-2 p-0 tooltipped-no-delay" data-copy-feedback="Copied!" data-tooltip-direction="w" value="for clauses <- Ecto.Schema.__schema__(fields, field_sources, assocs, embeds),
    {args, body} <- clauses do
  def __schema__(unquote_splicing(args)), do: unquote(body)
end
" tabindex="0" role="button">
            <svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" data-view-component="true" height="16" width="16" class="octicon octicon-clippy js-clipboard-clippy-icon m-2">
              <path fill-rule="evenodd" d="M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"></path>
            </svg>
            <svg aria-hidden="true" viewBox="0 0 16 16" version="1.1" data-view-component="true" height="16" width="16" class="octicon octicon-check js-clipboard-check-icon color-text-success d-none m-2">
              <path fill-rule="evenodd" d="M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"></path>
            </svg>
          </clipboard-copy>
        </div></div>
        <p>Need to have their arity not be the number of PsiElements in the parentheses.  Any call to <code>unquote_splicing(...)</code> can end up have 0 to infinite parameters, so it means when one is saw, the range of <code>minimum...maximum</code> should change to an open interval of <code>minimum...</code>.  This required changing <code>IntRange resolvedFinalArityChange()</code> to <code>ArityInterval resolvedFinalArityInterval()</code> on all <code>Call</code>s, which was a large change.  It also meant changing a lot of ArityRange types to ArityInterval, and NameArityRange to NameArityInterval, which influenced the variable names.</p>
        <p>Since all Calls support ArityIntervals now and not just special forms and Ecto DSLs, exportArity is changed to always state the ResolveState, so that the special form changes can be integrated for all callers.</p>
        <p>The actual implementation of CallImpl.resolvedFinalArityRange is changes to fold over the ArityInterval:</p>
        <ul>
          <li>Normal arguments increase the minimum and maximum.</li>
          <li>Default arguments increase only the maximum.</li>
          <li>unquote_splicing changes the maximum to null to indicate the interval is half open.</li>
        </ul>
      </li>
      <li>Convert MissingSDK errors for Dialyzer into Notifications.</li>
      <li>
        Log element in psi.scope.Type instead of using <code>TODO()</code><br>
        Error will still be reported, but there will be enough information to triage and since <code>true</code> is
        returned now it won't stop the type resolving from working.
      </li>
      <li>
        Add missing mix deps options to non-path influencing list:
        <ul>
          <li>env</li>
          <li>manager</li>
          <li>repo</li>
          <li>sparse</li>
          <li>submodules</li>
          <li>system_env</li>
        </ul>
      </li>
      <li>
        Fix Fix incorrect <code>OuterElementType</code> in <code>eex.lexer.TemplateData</code>.<br/>
        The <code>EEX</code> <code>IElementType</code> needs to use <code>OuterLanguageElementType</code> instead of the
        direct <code>eex.psi.TokenType</code>.
      </li>
      <li>
        Run <code>QualifiedAlias#text</code> in <code>runReadAction</code> for <code>QualifiedAlias#name</code>
      </li>
      <li>
        Return <code>null</code> <code>Chunk</code> instead of throwing <code>IOException</code> when read incomplete.<br>
        Incomplete reads happen often due to incomplete writes to the file system being read in. As such, they shouldn't
        generate error reports and instead should be silently ignored.
      </li>
      <li>
        Implement <code>beam.FileEditor#getFile</code> to fix <code>DeprecatedMethodException</code> as the default
        implementation is now deprecated and requires an explicit implementation.
      </li>
      <li>
        Use <code>TabbedPaneWrapper.AsJBTabs</code> instead of <code>JBTabbedPane</code> for "BEAM Chunks" tabs.<br>
        I'm not sure why <code>JBTabbedPane</code> stopped showing its labels sometime in the 2020.X IDE version series,
        but by debugging when "BEAM Chunks" name was retrieved I found that the bottom tabs used
        <code>TabbedPaneWrapper.asJBTabs</code>.  Using that, the labels reappeared.
      </li>
      <li>
        Don't require Alias qualifier to be a <code>PsiNamedElement</code><br>
        It can be an <code>ElixirAtom</code> and getting the reference will still work.
      </li>
      <li><code>Any.isDecompiled</code> for <code>CallDefinitionHead</code>.</li>
    </ul>
  </li>
  <li>
    <p>Enhancements</p>
    <ul>
      <li>Only descend into modular children of modular for Module scope.  Prevents recursion loops on use calls.</li>
      <li>Don't search for unquoted variable value variable is value for <code>do:</code>.</li>
      <li>Protect from <code>IndexNotReady</code> in <code>resolver.Module.multiResolveProject</code>.</li>
      <li>Stop walking unquoted variable that resolves to a parameter.</li>
      <li>
        Walk case in <code>__using__</code> to find quote in any clause.  Fixes resolving test macro from
        <code>use PowerAssert</code>
      </li>
      <li>
        Resolve functions declared in <code>quote</code>'s scope when <code>block</code> injected with
        <code>unquote(block)</code>.<br>
        Fixes resolving <code>field</code>, <code>timestamps</code>, and <code>index</code> in <code>schema</code> for
        <code>use Yacto.Schema</code> as it makes the <code>block</code> see the <code>import Yacto.Schema</code> above
        <code>unquote(block)</code> in the <code>quote</code> in <code>schema(..., do: block)</code>.
      </li>
    </ul>
  </li>
</ul>
</body>
</html>
