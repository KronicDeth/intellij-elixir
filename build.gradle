import org.jetbrains.intellij.platform.gradle.IntelliJPlatformType
import org.jetbrains.intellij.platform.gradle.TestFrameworkType
import org.jetbrains.intellij.platform.gradle.models.ProductRelease
import org.jetbrains.intellij.platform.gradle.tasks.RunIdeTask
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.dsl.KotlinVersion
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile

plugins {
    id "org.jetbrains.intellij.platform" version "2.9.0"
    id "org.jetbrains.kotlin.jvm" version "2.2.20"
    id "de.undercouch.download" version "5.6.0"
    id 'com.adarshr.test-logger' version '4.0.0'
}

apply plugin: "org.jetbrains.intellij.platform"

ext {
    cachePath = "${rootDir}/cache"

    elixirPath = "${cachePath}/elixir-${elixirVersion}"

    quoterVersion = "2.1.0"

    quoterUnzippedPath = "${cachePath}/elixir-${elixirVersion}-intellij_elixir-${quoterVersion}"
    quoterReleasePath = "${quoterUnzippedPath}/_build/dev/rel/intellij_elixir"
    quoterExe = "${quoterReleasePath}/bin/intellij_elixir"
    quoterZipPath = "${cachePath}/intellij_elixir-${quoterVersion}.zip"
    quoterZipRootPath = "${cachePath}/intellij_elixir-${quoterVersion}"

    def baseVersion = providers.gradleProperty("pluginVersion").get()

    publishChannelProperty = providers.gradleProperty("publishChannel").getOrElse("canary")
    if (publishChannelProperty == "default") {
        versionSuffix = ""
    }
    // if versionSuffix gradle property is set, use it, it will append -<versionSuffix> to the base version
    // Check if versionSuffix exists and is not empty
    else if (providers.gradleProperty("versionSuffix").isPresent() && !providers.gradleProperty("versionSuffix").get().isEmpty()) {
        versionSuffix = "-${providers.gradleProperty("versionSuffix").get()}"
    } else {
        def date = new Date().format("yyyyMMddHHmmss", TimeZone.getTimeZone("UTC"))
        versionSuffix = "-pre+$date"
    }

    pluginVersion = "$baseVersion$versionSuffix"
}

allprojects {
    apply plugin: 'java'
    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
    tasks.withType(JavaCompile).tap { configureEach { options.encoding = 'UTF-8' } }
}
subprojects {
    apply plugin: 'org.jetbrains.intellij.platform.module'
    repositories {
        mavenCentral()
        intellijPlatform {
            defaultRepositories()
        }
    }
    dependencies {
        testImplementation 'junit:junit:4.13.2'
        testImplementation "org.opentest4j:opentest4j:1.3.0"

        intellijPlatform {
            create(providers.gradleProperty("platformType"), providers.gradleProperty("platformVersion"))

            bundledPlugins providers.gradleProperty("platformBundledPlugins").map { it.split(',').toList() }
            bundledModules providers.gradleProperty("platformBundledModules").map { it.split(',').toList() }

            instrumentationTools()
            pluginVerifier()
            zipSigner()
            testFramework(TestFrameworkType.Platform.INSTANCE)
            testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
        }
    }
    sourceSets {
        main {
            java.srcDirs 'src'
            resources.srcDirs 'resources'
        }
        test {
            java.srcDir 'tests'
        }
    }
}

sourceSets {
    main {
        java.srcDirs 'src', 'gen'
        resources.srcDirs 'resources'
    }
    test {
        java.srcDir 'tests'
    }
}
intellijPlatform {
    // don't buildSearchableOptions/instrumentCode if publishChannel is canary.
    if (publishChannelProperty == "canary") {
        buildSearchableOptions = false
        instrumentCode = false
    }
    pluginConfiguration {
        def stripTag = { text, tag -> text.replace("<${tag}>", "").replace("</${tag}>", "") }
        def bodyInnerHTML = { path -> stripTag(stripTag(file(path).text, "html"), "body") }

        id = providers.gradleProperty("pluginGroup")
        name = providers.gradleProperty("pluginName")
        version = pluginVersion
        changeNotes.set(bodyInnerHTML("resources/META-INF/changelog.html"))
        description.set(bodyInnerHTML("resources/META-INF/description.html"))

        ideaVersion {
            sinceBuild = providers.gradleProperty("pluginSinceBuild")
            // We want users to be able to install the plugin on future versions, and if there is incompatibility,
            // they should hopefully create an issue :-).
            untilBuild = provider { null }
        }
        vendor {
            name = providers.gradleProperty("vendorName")
            email = providers.gradleProperty("vendorEmail")
            url = providers.gradleProperty("pluginRepositoryUrl")
        }
    }

    signPlugin {
        certificateChain = providers.environmentVariable("IJ_CERTIFICATE_CHAIN")
        privateKey = providers.environmentVariable("IJ_PRIVATE_KEY")
        password = providers.environmentVariable("IJ_PRIVATE_KEY_PASSWORD")
    }


    buildPlugin {
        // if -PpluginName exists, use it, or fallback to intellij-elixir. Not sure how to override otherwise.
        archiveBaseName = providers.gradleProperty("pluginDistributionName").getOrElse("intellij-elixir")
    }

    publishing {
        channels = [publishChannelProperty]
    }

    publishPlugin {
        token = provider {
            System.getenv("JET_BRAINS_MARKETPLACE_TOKEN")
        }
        // Use the path from the -PdistributionFile property if it exists,
        // otherwise fall back to the old environment variable method.
        if (project.hasProperty("distributionFile")) {
            archiveFile = file(project.property("distributionFile"))
        } else if (System.getenv("ASSET_NAME")) {
            archiveFile = layout.buildDirectory.file("distributions/${System.getenv("ASSET_NAME")}")
        }
    }
    pluginVerification {
        ides {
            // since 253.* (2025.3+), IntelliJ IDEA Community and Ultimate have been merged into IntelliJ IDEA
            select {
                it.types = [IntelliJPlatformType.IntellijIdeaCommunity]
                it.untilBuild = '252.*'
            }
            select {
                it.types = [IntelliJPlatformType.IntellijIdeaUltimate]
                it.sinceBuild = '253'
            }
            ide(IntelliJPlatformType.IntellijIdeaCommunity, "2024.2.6")
            ide(IntelliJPlatformType.IntellijIdeaCommunity, "2024.3.6")
            ide(IntelliJPlatformType.IntellijIdeaCommunity, "2025.2.2")
        }
    }

}
apply plugin: "kotlin"

// Configure all RunIdeTask instances (including the new platform-specific ones)
tasks.withType(RunIdeTask).configureEach {
    // Set JVM arguments
    jvmArguments.addAll(["-Didea.debug.mode=true", "-Didea.is.internal=true", "-Dlog4j2.debug=true", "-Dlogger.org=TRACE", "-XX:+AllowEnhancedClassRedefinition", "-XXHotswapAgent=fatjar"])

    // Set system properties to debug log
    systemProperty "idea.log.debug.categories", "org.elixir_lang"

    // Set the maximum heap size
    maxHeapSize = "7g"

    // Optionally set the working directory if specified in the project properties
    if (project.hasProperty("runIdeWorkingDirectory") && !project.property("runIdeWorkingDirectory").isEmpty()) {
        workingDir = file(project.property("runIdeWorkingDirectory"))
    }

    def compatiblePluginsList = providers.gradleProperty("runIdeCompatiblePlugins").get().with { it.isEmpty() ? [] : it.split(",") }
    if (compatiblePluginsList.size() > 0) {
        dependencies {
            intellijPlatform {
                compatiblePlugins(compatiblePluginsList)
            }
        }
    }
}

kotlin {
    jvmToolchain(21)
}

tasks.withType(KotlinJvmCompile).configureEach {
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_21)
        freeCompilerArgs.add("-Xjvm-default=all")
        apiVersion.set(KotlinVersion.KOTLIN_2_2)
    }
}

def compilationPackages = ['org/intellij/elixir/build/**', 'org/intellij/elixir/jps/**']

test {
    environment "ELIXIR_LANG_ELIXIR_PATH", elixirPath
    environment "ELIXIR_EBIN_DIRECTORY", "${elixirPath}/lib/elixir/ebin/"
    environment "ELIXIR_VERSION", elixirVersion
    setScanForTestClasses(false)
    include("**/Issue*.class")
    include("**/*Test.class")
    include("**/*TestCase.class")
    useJUnit {
        exclude compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

// Get the list of platforms from gradle.properties
def runIdePlatformsList = providers.gradleProperty("runIdePlatforms").get().split(",")

intellijPlatformTesting {
    runIde {
        runIdePlatformsList.each { platform ->
            "run${platform}" {
                type = IntelliJPlatformType."${platform}"
                version = providers.gradleProperty("platformVersion${platform}").get()

                prepareSandboxTask {
                    sandboxDirectory = project.layout.buildDirectory.dir("${platform.toLowerCase()}-sandbox")
                }
            }

            // if enableEAPIDEs is true, create an EAP instance
            if (providers.gradleProperty("enableEAPIDEs").get().toLowerCase() == "true") {
                "run${platform}EAP" {
                    type = IntelliJPlatformType."${platform}"
                    version = providers.gradleProperty("platformVersion${platform}EAP").get()
                    useInstaller = false

                    prepareSandboxTask {
                        sandboxDirectory = project.layout.buildDirectory.dir("${platform.toLowerCase()}_eap-sandbox")
                    }
                }
            }
        }
    }
}

task testCompilation(type: Test, group: 'Verification', dependsOn: [classes, testClasses]) {
    useJUnit {
        include compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

repositories {
    maven { url = 'https://maven-central.storage.googleapis.com' }
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
    }
}

dependencies {
    intellijPlatform {
        create(providers.gradleProperty("platformType"), providers.gradleProperty("platformVersion"))

        bundledPlugins(providers.gradleProperty("platformBundledPlugins").map { it.split(',').toList() })
        bundledModules(providers.gradleProperty("platformBundledModules").map { it.split(',').toList() })
        instrumentationTools()
        pluginVerifier()
        zipSigner()
        testFramework(TestFrameworkType.Platform.INSTANCE)
        testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
    }

    implementation project(':jps-builder')
    implementation project(':jps-shared')
    implementation files('lib/OtpErlang.jar')
    implementation group: 'commons-io', name: 'commons-io', version: '2.20.0'

    testImplementation 'junit:junit:4.13.2'
    testImplementation "org.opentest4j:opentest4j:1.3.0"

    testImplementation group: 'org.mockito', name: 'mockito-core', version: '5.19.0'
    testImplementation group: 'org.objenesis', name: 'objenesis', version: '3.4'
}
compileJava {
    dependsOn ':jps-shared:composedJar'
    dependsOn ':jps-builder:composedJar'
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}

tasks.register('getElixir') {
    doLast {
        def folder = new File(elixirPath as String)

        if (!folder.isDirectory() || folder.list().size() == 0) {
            download.run {
                src "https://github.com/elixir-lang/elixir/archive/v${elixirVersion}.zip"
                dest "${rootDir}/cache/Elixir.${elixirVersion}.zip"
                overwrite false
            }
        }

        def binFolder = new File("${elixirPath}/bin")
        if (!binFolder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree("${rootDir}/cache/Elixir.${elixirVersion}.zip")
                into "${rootDir}/cache/"
            }

            exec {
                workingDir elixirPath
                commandLine "make"
            }
        }
    }
}

task getQuoter {
    doLast {
        download.run {
            src "https://github.com/KronicDeth/intellij_elixir/archive/v${quoterVersion}.zip"
            dest quoterZipPath
            overwrite false
        }

        def folder = new File(quoterUnzippedPath)
        if (!folder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree(quoterZipPath)
                into cachePath
            }

            def quoterZipRootFile = new File(quoterZipRootPath)

            quoterZipRootFile.renameTo(quoterUnzippedPath)
        }
    }
}

task getQuoterDeps(dependsOn: getQuoter) {
    doLast {
        exec {
            workingDir quoterUnzippedPath
            commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get'
            // standardOutput = System.out
            // errorOutput = System.err
        }
    }
}

task releaseQuoter(dependsOn: getQuoterDeps) {
    doLast {
        def file = new File(quoterExe)

        if (!file.canExecute()) {
            exec {
                workingDir quoterUnzippedPath
                commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get,', 'release'
                // standardOutput = System.out
                // errorOutput = System.err
            }
        }
    }
}

compileTestJava {
    dependsOn ":jps-builder:composedJar"
    dependsOn ":jps-shared:composedJar"
    dependsOn getElixir
    dependsOn getQuoter
}

task runQuoter(type: Exec, dependsOn: releaseQuoter) {
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "daemon"
}

task stopQuoter(type: Exec, dependsOn: releaseQuoter) {
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "stop"
}

runIde {
    systemProperty "idea.log.debug.categories", "org.elixir_lang"
    // When wanting to disable EDT slow assertion..
    // systemProperty "ide.slow.operations.assertion", "true"

    // -Didea.debug.mode=true:
    // This enables debug mode for IntelliJ IDEA. It can be useful when developing plugins to get more detailed logging and debugging information.
    // -Didea.is.internal=true:
    // This flag indicates that the plugin is running in an internal mode, which may enable additional features or logging that are typically only available to IntelliJ developers.
    // -Dlog4j2.debug=true:
    // This enables debug logging for Log4j 2, which is the logging framework used by IntelliJ IDEA. It can help in troubleshooting logging-related issues in your plugin.
    // -Dlogger.org=TRACE:
    // This sets the logging level for the "org" package to TRACE, which is the most verbose logging level. This can be useful for detailed logging of plugin activities.
    // -XX:+AllowEnhancedClassRedefinition:
    // This is a JVM flag that allows for more flexible class redefinition during runtime. It can be beneficial for hot-swapping code changes without restarting the IDE.
    // -Didea.ProcessCanceledException=disabled:
    //This disables the throwing of ProcessCanceledException, which is typically used to cancel long-running processes in IntelliJ IDEA. Disabling it can be useful in certain debugging scenarios.
    jvmArgs "-Didea.debug.mode=true", "-XX:+AllowEnhancedClassRedefinition", "-Didea.is.internal=true", "-Dlog4j2.debug=true", "-Dlogger.org=TRACE", "-Didea.ProcessCanceledException=disabled"
    maxHeapSize = "7g"
    autoReload = false
    // get from runIdeWorkingDirectory
    if (project.hasProperty("runIdeWorkingDirectory") && !project.property("runIdeWorkingDirectory").isEmpty()) {
        workingDir = file(project.property("runIdeWorkingDirectory"))
    }
}

test {
    dependsOn runQuoter
    finalizedBy stopQuoter
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}

tasks {
    printProductsReleases {
        channels = [ProductRelease.Channel.EAP]
        // From gradle.properties.
        types = [
                IntelliJPlatformType.IntellijIdeaCommunity,
                IntelliJPlatformType.IntellijIdeaUltimate,
                IntelliJPlatformType.PhpStorm,
                IntelliJPlatformType.PyCharmCommunity,
                IntelliJPlatformType.PyCharmProfessional,
                IntelliJPlatformType.WebStorm,
                IntelliJPlatformType.RubyMine
        ]
        untilBuild = null

        doLast {
            def latestEap = productsReleases.get().max()
        }
    }
}

// Uncomment to allow using build-scan.
//if (hasProperty('buildScan')) {
//    buildScan {
//        termsOfServiceUrl = 'https://gradle.com/terms-of-service'
//        termsOfServiceAgree = 'yes'
//    }
//}
