import org.codehaus.groovy.runtime.GStringImpl
import org.jetbrains.intellij.platform.gradle.IntelliJPlatformType
import org.jetbrains.intellij.platform.gradle.TestFrameworkType
import org.jetbrains.intellij.platform.gradle.tasks.RunIdeTask
import org.jetbrains.kotlin.gradle.dsl.JvmTarget
import org.jetbrains.kotlin.gradle.dsl.KotlinVersion
import org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile
import javax.xml.parsers.DocumentBuilderFactory

plugins {
    id "org.jetbrains.intellij.platform" version "2.10.5"
    id "org.jetbrains.kotlin.jvm" version "2.2.21"
    id "de.undercouch.download" version "5.6.0"
    id 'com.adarshr.test-logger' version '4.0.0'
}

apply plugin: "org.jetbrains.intellij.platform"

// Function to fetch the latest EAP build number dynamically
static String latestEapBuild() {
    // 1) Prefer JetBrains Releases API to get a concrete numeric EAP build (e.g., 253.28294.169)
    List<URI> apiUris = [
            new URI("https://data.services.jetbrains.com/products/releases?code=IIU&type=eap&latest=true&fields=build"),
            new URI("https://data.services.jetbrains.com/products/releases?code=IIU&type=eap&latest=true")
    ]
    for (URI uri in apiUris) {
        String json
        try {
            json = uri.toURL().openStream().withReader('UTF-8') { it.text }
        } catch (Exception ignored) {
            continue
        }
        if (json) {
            def matcher = json =~ /"build"\s*:\s*"([0-9.]+)"/
            if (matcher.find()) {
                return matcher.group(1) as String // e.g., 253.28294.169
            }
        }
    }

    // 2) Fallback: parse snapshots metadata and pick the last 3-part numeric EAP snapshot, then strip the suffix
    URI snapshotsUri = new URI("https://cache-redirector.jetbrains.com/www.jetbrains.com/intellij-repository/snapshots/com/jetbrains/intellij/idea/ideaIU/maven-metadata.xml")
    List<String> versions = []
    try {
        def doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(snapshotsUri.toURL().openStream())
        doc.documentElement.normalize()
        def versioning = doc.getElementsByTagName("versioning").item(0)
        def versionsNode = versioning?.childNodes
        if (versionsNode != null) {
            for (int i = 0; i < versionsNode.length; i++) {
                def n = versionsNode.item(i)
                if (n.nodeName == "versions") {
                    def children = n.childNodes
                    for (int j = 0; j < children.length; j++) {
                        def v = children.item(j)
                        if (v.nodeName == "version") {
                            versions.add(v.textContent as String)
                        }
                    }
                }
            }
        }
    } catch (Exception ignored) {
        // Fallback failed
    }

    // Look for versions like 253.17525.95-EAP-SNAPSHOT and convert to 253.17525.95
    String numericEap = versions.findAll { v ->
        v ==~ /^\d+\.\d+\.\d+-EAP-SNAPSHOT$/
    }.collect { v ->
        v.replaceAll(/-EAP-SNAPSHOT$/, '') as String
    }.lastOrNull()

    if (numericEap != null) return numericEap

    throw new IllegalStateException("No numeric EAP build found from JetBrains API or snapshots metadata")
}

ext {
    cachePath = "${rootDir}/cache" as GStringImpl

    elixirPath = "${cachePath}/elixir-${elixirVersion}" as GStringImpl

    quoterVersion = "2.1.0"

    // Determine the actual platform version to use
    actualPlatformVersion = (project.hasProperty("useDynamicEapVersion") && useDynamicEapVersion.toBoolean()
            ? latestEapBuild()
            : platformVersion).toString()

    println("Building against IntelliJ Platform version: ${actualPlatformVersion}")

    quoterUnzippedPath = "${cachePath}/elixir-${elixirVersion}-intellij_elixir-${quoterVersion}" as GStringImpl
    quoterReleasePath = "${quoterUnzippedPath}/_build/dev/rel/intellij_elixir" as GStringImpl
    quoterExe = "${quoterReleasePath}/bin/intellij_elixir" as GStringImpl
    quoterZipPath = "${cachePath}/intellij_elixir-${quoterVersion}.zip" as GStringImpl
    quoterZipRootPath = "${cachePath}/intellij_elixir-${quoterVersion}" as GStringImpl

    if (project.hasProperty("isRelease") && isRelease) {
        versionSuffix = "" as GStringImpl
        channel = "default"
    } else {
        def date = new Date().format("yyyyMMddHHmmss", TimeZone.getTimeZone("UTC"))
        versionSuffix = "-pre+$date" as GStringImpl
        channel = "canary"
    }

    version = "$pluginVersion$versionSuffix" as GStringImpl
}

allprojects {
    apply plugin: 'java'
    java {
        sourceCompatibility = JavaVersion.VERSION_21
        targetCompatibility = JavaVersion.VERSION_21
    }
    tasks.withType(JavaCompile).tap { configureEach { options.encoding = 'UTF-8' } }
}
subprojects {
    apply plugin: 'org.jetbrains.intellij.platform.module'
    repositories {
        mavenCentral()
        intellijPlatform {
            defaultRepositories()
        }
    }
    dependencies {
        testImplementation 'junit:junit:4.13.2'
        testImplementation "org.opentest4j:opentest4j:1.3.0"

        intellijPlatform {
            create(providers.gradleProperty("platformType"), provider { actualPlatformVersion })

            bundledPlugins providers.gradleProperty("platformBundledPlugins").map { it.split(',').toList() }
            bundledModules providers.gradleProperty("platformBundledModules").map { it.split(',').toList() }

            instrumentationTools()
            pluginVerifier()
            zipSigner()
            testFramework(TestFrameworkType.Platform.INSTANCE)
            testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
        }
    }
    sourceSets {
        main {
            java.srcDirs 'src'
            resources.srcDirs 'resources'
        }
        test {
            java.srcDir 'tests'
        }
    }

}
sourceSets {
    main {
        java.srcDirs 'src', 'gen'
        resources.srcDirs 'resources'
    }
    test {
        java.srcDir 'tests'
    }
}
intellijPlatform {
    // buildSearchableOptions = false
    // instrumentCode = false
    pluginConfiguration {
        def stripTag = { text, tag -> text.replace("<${tag}>", "").replace("</${tag}>", "") }
        def bodyInnerHTML = { path -> stripTag(stripTag(file(path).text, "html"), "body")
        }

        id = providers.gradleProperty("pluginGroup")
        name = providers.gradleProperty("pluginName")
        version = providers.gradleProperty("pluginVersion")
        changeNotes.set(bodyInnerHTML("resources/META-INF/changelog.html"))
        description.set(bodyInnerHTML("resources/META-INF/description.html"))

        ideaVersion {
            sinceBuild = providers.gradleProperty("pluginSinceBuild")
            // We want users to be able to install the plugin on future versions, and if there is incompatibility,
            // they should hopefully create an issue :-).
            untilBuild = provider { null }
        }
        vendor {
            name = providers.gradleProperty("vendorName")
            email = providers.gradleProperty("vendorEmail")
            url = providers.gradleProperty("pluginRepositoryUrl")
        }
    }

    publishPlugin {
        token = provider {
            System.getenv("JET_BRAINS_MARKETPLACE_TOKEN")
        }
        channels = publishChannels.split(',').toList()
        archiveFile = layout.buildDirectory.file("distributions/${System.getenv("ASSET_NAME")}")
    }
    pluginVerification {
        ides {
            // https://www.jetbrains.com/idea/download/other.html
            // Note: Using IntellijIdeaUltimate as IC is no longer available in 2025.3+
//            ide(IntelliJPlatformType.IntellijIdeaCommunity, "2024.2.6")
//            ide(IntelliJPlatformType.IntellijIdeaCommunity, "2024.3.6")
//            ide IntelliJPlatformType.IntellijIdeaUltimate, "2025.2.1"
            // Testing against 2025.3 EAP - using the same build we're compiling against
            ide IntelliJPlatformType.IntellijIdeaUltimate, actualPlatformVersion
        }
    }
}
apply plugin: "kotlin"

// Configure all RunIdeTask instances (including the new platform-specific ones)
tasks.withType(RunIdeTask).configureEach {
    // Set JVM arguments
    jvmArguments.addAll(["-Didea.debug.mode=true", "-Didea.is.internal=true", "-Dlog4j2.debug=true", "-Dlogger.org=TRACE", "-XX:+AllowEnhancedClassRedefinition"])

    // Set system properties to debug log
    systemProperty "idea.log.debug.categories", "org.elixir_lang"

    // Set the maximum heap size
    maxHeapSize = "7g"

    // Optionally set the working directory if specified in the project properties
    if (project.hasProperty("runIdeWorkingDirectory") && !project.property("runIdeWorkingDirectory").isEmpty()) {
        workingDir = file(project.property("runIdeWorkingDirectory"))
    }

    def compatiblePluginsList = providers.gradleProperty("runIdeCompatiblePlugins").get().with { it.isEmpty() ? [] : it.split(",") }
    if (compatiblePluginsList.size() > 0) {
        dependencies {
            intellijPlatform {
                compatiblePlugins(compatiblePluginsList)
            }
        }
    }
}

kotlin {
    jvmToolchain(21)
}

tasks.withType(KotlinJvmCompile).configureEach {
    compilerOptions {
        jvmTarget.set(JvmTarget.JVM_21)
        freeCompilerArgs.add("-Xjvm-default=all")
        apiVersion.set(KotlinVersion.KOTLIN_2_2)
    }
}

def compilationPackages = ['org/intellij/elixir/build/**', 'org/intellij/elixir/jps/**']

test {
    environment "ELIXIR_LANG_ELIXIR_PATH", elixirPath
    environment "ELIXIR_EBIN_DIRECTORY", "${elixirPath}/lib/elixir/ebin/"
    environment "ELIXIR_VERSION", elixirVersion
    setScanForTestClasses(false)
    include("**/Issue*.class")
    include("**/*Test.class")
    include("**/*TestCase.class")

    // Exclude specific abstract base test classes so that they don't show as Ignored
    exclude("**/org/elixir_lang/PlatformTestCase.class")
    exclude("**/org/elixir_lang/eex/lexer/look_ahead/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/TokenTest.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group/quote/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group/sigil/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/quote/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/char_list/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/custom/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/regex/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/string/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_end/sigil/words/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_line_body/quote/PromoterTest.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/group_heredoc_line_body/sigil/PromoterTest.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/named_sigil/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/sigil_modifiers/group/Test.class")
    exclude("**/org/elixir_lang/elixir_flex_lexer/sigil_modifiers/group_heredoc_end/Test.class")
    exclude("**/org/elixir_lang/flex_lexer/Test.class")
    exclude("**/org/elixir_lang/parser_definition/ParsingTestCase.class")
    exclude("**/org/elixir_lang/parser_definition/matched_call_operation/ParsingTestCase.class")
    exclude("**/org/elixir_lang/parser_definition/matched_dot_operator_call_operation/ParsingTestCase.class")

    useJUnit {
        exclude compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

// Get the list of platforms from gradle.properties
def runIdePlatformsList = providers.gradleProperty("runIdePlatforms").get().split(",")

intellijPlatformTesting {
    runIde {
        runIdePlatformsList.each { platform ->
            "run${platform}" {
                type = IntelliJPlatformType."${platform}"
                version = providers.gradleProperty("platformVersion${platform}").get()

                prepareSandboxTask {
                    sandboxDirectory = project.layout.buildDirectory.dir("${platform.toLowerCase()}-sandbox")
                }
            }

            // if enableEAPIDEs is true, create an EAP instance
            if (providers.gradleProperty("enableEAPIDEs").get().toLowerCase() == "true") {
                "run${platform}EAP" {
                    type = IntelliJPlatformType."${platform}"
                    version = providers.gradleProperty("platformVersion${platform}EAP").get()
                    useInstaller = false

                    prepareSandboxTask {
                        sandboxDirectory = project.layout.buildDirectory.dir("${platform.toLowerCase()}_eap-sandbox")
                    }
                }
            }
        }
    }
}

tasks.register('testCompilation', Test) {
    group = 'Verification'
    dependsOn = [classes, testClasses]
    useJUnit {
        include compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

repositories {
    maven { url = 'https://maven-central.storage.googleapis.com' }
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
    }
}

dependencies {
    intellijPlatform {
        create(providers.gradleProperty("platformType"), provider { actualPlatformVersion })

        bundledPlugins(providers.gradleProperty("platformBundledPlugins").map { it.split(',').toList() })
        bundledModules(providers.gradleProperty("platformBundledModules").map { it.split(',').toList() })
        instrumentationTools()
        pluginVerifier()
        zipSigner()
        testFramework(TestFrameworkType.Platform.INSTANCE)
        testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
    }

    implementation project(':jps-builder')
    implementation project(':jps-shared')
    implementation files('lib/OtpErlang.jar')
    implementation group: 'commons-io', name: 'commons-io', version: '2.21.0'

    testImplementation 'junit:junit:4.13.2'
    testImplementation "org.opentest4j:opentest4j:1.3.0"
}
compileJava {
    dependsOn ':jps-shared:composedJar'
    dependsOn ':jps-builder:composedJar'
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}

tasks.register('getElixir') {
    doLast {
        def folder = new File(elixirPath as String)

        if (!folder.isDirectory() || folder.list().size() == 0) {
            download.run {
                src "https://github.com/elixir-lang/elixir/archive/v${elixirVersion}.zip"
                dest "${rootDir}/cache/Elixir.${elixirVersion}.zip"
                overwrite false
            }
        }

        def binFolder = new File("${elixirPath}/bin")
        if (!binFolder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree("${rootDir}/cache/Elixir.${elixirVersion}.zip")
                into "${rootDir}/cache/"
            }

            exec {
                workingDir elixirPath
                commandLine "make"
            }
        }
    }
}

tasks.register('getQuoter') {
    doLast {
        download.run {
            src "https://github.com/KronicDeth/intellij_elixir/archive/v${quoterVersion}.zip"
            dest quoterZipPath
            overwrite false
        }

        def folder = new File(quoterUnzippedPath as String)
        if (!folder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree(quoterZipPath)
                into cachePath
            }

            def quoterZipRootFile = new File(quoterZipRootPath as String)

            quoterZipRootFile.renameTo(quoterUnzippedPath as File)
        }
    }
}

tasks.register('getQuoterDeps') {
    doLast {
        exec {
            workingDir quoterUnzippedPath
            commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get'
            // standardOutput = System.out
            // errorOutput = System.err
        }
    }
}

tasks.register('releaseQuoter') {
    doLast {
        def file = new File(quoterExe as String)

        if (!file.canExecute()) {
            exec {
                workingDir quoterUnzippedPath
                commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get,', 'release'
                // standardOutput = System.out
                // errorOutput = System.err
            }
        }
    }
}

compileTestJava {
    dependsOn ":jps-builder:composedJar"
    dependsOn ":jps-shared:composedJar"
    dependsOn getElixir
    dependsOn getQuoter
}

tasks.register('runQuoter', Exec) {
    dependsOn releaseQuoter
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "daemon"
}

tasks.register('stopQuoter', Exec) {
    dependsOn releaseQuoter
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "stop"
}

runIde {
    systemProperty "idea.log.debug.categories", "org.elixir_lang=TRACE"
    // When wanting to disable EDT slow assertion..
    // systemProperty "ide.slow.operations.assertion", "true"

    // -Didea.debug.mode=true:
    // This enables debug mode for IntelliJ IDEA. It can be useful when developing plugins to get more detailed logging and debugging information.
    // -Didea.is.internal=true:
    // This flag indicates that the plugin is running in an internal mode, which may enable additional features or logging that are typically only available to IntelliJ developers.
    // -Dlog4j2.debug=true:
    // This enables debug logging for Log4j 2, which is the logging framework used by IntelliJ IDEA. It can help in troubleshooting logging-related issues in your plugin.
    // -Dlogger.org=TRACE:
    // This sets the logging level for the "org" package to TRACE, which is the most verbose logging level. This can be useful for detailed logging of plugin activities.
    // -XX:+AllowEnhancedClassRedefinition:
    // This is a JVM flag that allows for more flexible class redefinition during runtime. It can be beneficial for hot-swapping code changes without restarting the IDE.
    // -Didea.ProcessCanceledException=disabled:
    //This disables the throwing of ProcessCanceledException, which is typically used to cancel long-running processes in IntelliJ IDEA. Disabling it can be useful in certain debugging scenarios.
    jvmArgs "-Didea.debug.mode=true", "-XX:+AllowEnhancedClassRedefinition", "-Didea.is.internal=true", "-Dlog4j2.debug=true", "-Dlogger.org=TRACE", "-Didea.ProcessCanceledException=disabled"
    maxHeapSize = "7g"
    // get from runIdeWorkingDirectory
    if (project.hasProperty("runIdeWorkingDirectory") && !project.property("runIdeWorkingDirectory").isEmpty()) {
        workingDir = file(project.property("runIdeWorkingDirectory"))
    }
}

test {
    dependsOn prepareTestSandbox, runQuoter
    finalizedBy stopQuoter
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}

// Uncomment to allow using build-scan.
// if (hasProperty('buildScan')) {
//     buildScan {
//         termsOfServiceUrl = 'https://gradle.com/terms-of-service'
//         termsOfServiceAgree = 'yes'
//     }
// }
