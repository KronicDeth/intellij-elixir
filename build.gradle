import org.jetbrains.intellij.platform.gradle.TestFrameworkType
import org.jetbrains.intellij.platform.gradle.extensions.IntelliJPlatformDependenciesExtension

plugins {
    id "org.jetbrains.intellij.platform" version "2.0.0"
    id "org.jetbrains.kotlin.jvm" version "1.9.10"
    id "de.undercouch.download" version "4.1.2"
    id 'com.adarshr.test-logger' version '4.0.0'
}

apply plugin: "org.jetbrains.intellij.platform"

ext {
    cachePath = "${rootDir}/cache"

    elixirPath = "${cachePath}/elixir-${elixirVersion}"

    quoterVersion = "2.1.0"

    quoterUnzippedPath = "${cachePath}/elixir-${elixirVersion}-intellij_elixir-${quoterVersion}"
    quoterReleasePath = "${quoterUnzippedPath}/_build/dev/rel/intellij_elixir"
    quoterExe = "${quoterReleasePath}/bin/intellij_elixir"
    quoterZipPath = "${cachePath}/intellij_elixir-${quoterVersion}.zip"
    quoterZipRootPath = "${cachePath}/intellij_elixir-${quoterVersion}"

    if (project.hasProperty("isRelease") && isRelease) {
        versionSuffix = ""
        channel = "default"
    } else {
        def date = new Date().format("yyyyMMddHHmmss", TimeZone.getTimeZone("UTC"))
        versionSuffix = "-pre+$date"
        channel = "canary"
    }

    version "$baseVersion$versionSuffix"
}

allprojects {
    apply plugin: 'java'
    sourceCompatibility = javaVersion
    targetCompatibility = javaVersion
    tasks.withType(JavaCompile) { options.encoding = 'UTF-8' }
}
subprojects {
    apply plugin: 'org.jetbrains.intellij.platform.module'
    dependencies {
        testImplementation 'junit:junit:4.13.2'
        testImplementation "org.opentest4j:opentest4j:1.3.0"

        intellijPlatform {
            instrumentationTools()

            intellijIdeaCommunity("2024.1.4")

            bundledPlugins("com.intellij.java", "org.intellij.plugins.markdown")

            testFramework(TestFrameworkType.Platform.INSTANCE)
            // testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
        }
    }
    sourceSets {
        main {
            java.srcDirs 'src'
            resources.srcDirs 'resources'
        }
        test {
            java.srcDir 'tests'
        }
    }

}
sourceSets {
    main {
        java.srcDirs 'src', 'gen'
        resources.srcDirs 'resources'
    }
    test {
        java.srcDir 'tests'
    }
}
intellijPlatform {
    pluginConfiguration {
        id = providers.gradleProperty("pluginGroup")
        name = providers.gradleProperty("pluginName")
        version = providers.gradleProperty("pluginVersion")
        description = providers.gradleProperty("pluginDescription")
        changeNotes = providers.gradleProperty("pluginChangeNotes")
        ideaVersion {
            sinceBuild = providers.gradleProperty("pluginSinceBuild")
            untilBuild = providers.gradleProperty("pluginUntilBuild")
        }
        vendor {
            name = providers.gradleProperty("vendorName")
            email = providers.gradleProperty("vendorEmail")
            url = providers.gradleProperty("pluginRepositoryUrl")
        }
    }

    publishing {
        token = provider {
            System.getenv("JET_BRAINS_MARKETPLACE_TOKEN")
        }
        channels = publishChannels.split(',').toList()
    }
}
apply plugin: "kotlin"

//noinspection GroovyAssignabilityCheck,GrUnresolvedAccess
tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    //noinspection GrUnresolvedAccess
    kotlinOptions {
        apiVersion = "1.7"
        jvmTarget = "17"
        freeCompilerArgs = ["-Xjvm-default=all"]
    }
}

def compilationPackages = ['org/intellij/elixir/build/**', 'org/intellij/elixir/jps/**']

test {
    environment "ELIXIR_LANG_ELIXIR_PATH", elixirPath
    environment "ELIXIR_EBIN_DIRECTORY", "${elixirPath}/lib/elixir/ebin/"
    environment "ELIXIR_VERSION", elixirVersion
    setScanForTestClasses(false)
    include("**/Issue*.class")
    include("**/*Test.class")
    include("**/*TestCase.class")
    useJUnit {
        exclude compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

task testCompilation(type: Test, group: 'Verification', dependsOn: [classes, testClasses]) {
    useJUnit {
        include compilationPackages
    }
    testLogging {
        exceptionFormat = 'full'
    }
}

repositories {
    maven { url 'https://maven-central.storage.googleapis.com' }
    mavenCentral()
    intellijPlatform {
        defaultRepositories()
    }
}

dependencies {
    intellijPlatform {
        instrumentationTools()

        intellijIdeaCommunity("2024.1.4")

        bundledPlugins("com.intellij.java", "org.intellij.plugins.markdown")

        testFramework(TestFrameworkType.Platform.INSTANCE)
        testFramework(TestFrameworkType.Plugin.Java.INSTANCE)
    }
    implementation project(':jps-builder')
    implementation project(':jps-shared')
    implementation files('lib/OtpErlang.jar')
    implementation group: 'commons-io', name: 'commons-io', version: '2.5'

    testImplementation 'junit:junit:4.13.2'
    testImplementation "org.opentest4j:opentest4j:1.3.0"

    testImplementation group: 'org.mockito', name: 'mockito-core', version: '2.2.9'
    testImplementation group: 'org.objenesis', name: 'objenesis', version: '2.4'
}
compileJava {
    dependsOn ':jps-shared:composedJar'
    dependsOn ':jps-builder:composedJar'
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}

task getElixir {
    doLast {
        def folder = new File(elixirPath)

        if (!folder.isDirectory() || folder.list().size() == 0) {
            download {
                src "https://github.com/elixir-lang/elixir/archive/v${elixirVersion}.zip"
                dest "${rootDir}/cache/Elixir.${elixirVersion}.zip"
                overwrite false
            }
        }

        def binFolder = new File("${elixirPath}/bin")
        if (!binFolder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree("${rootDir}/cache/Elixir.${elixirVersion}.zip")
                into "${rootDir}/cache/"
            }

            exec {
                workingDir elixirPath
                commandLine "make"
            }
        }
    }
}

task getQuoter {
    doLast {
        download {
            src "https://github.com/KronicDeth/intellij_elixir/archive/v${quoterVersion}.zip"
            dest quoterZipPath
            overwrite false
        }

        def folder = new File(quoterUnzippedPath)
        if (!folder.isDirectory() || folder.list().size() == 0) {
            copy {
                from zipTree(quoterZipPath)
                into cachePath
            }

            def quoterZipRootFile = new File(quoterZipRootPath)

            quoterZipRootFile.renameTo(quoterUnzippedPath)
        }
    }
}

task getQuoterDeps(dependsOn: getQuoter) {
    doLast {
        exec {
            workingDir quoterUnzippedPath
            commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get'
            // standardOutput = System.out
            // errorOutput = System.err
        }
    }
}

task releaseQuoter(dependsOn: getQuoterDeps) {
    doLast {
        def file = new File(quoterExe)

        if (!file.canExecute()) {
            exec {
                workingDir quoterUnzippedPath
                commandLine 'mix', 'do', 'local.rebar', '--force,', 'local.hex', '--force,', 'deps.get,', 'release'
                // standardOutput = System.out
                // errorOutput = System.err
            }
        }
    }
}

compileTestJava {
    dependsOn getElixir
    dependsOn getQuoter
}

task runQuoter(type: Exec, dependsOn: releaseQuoter) {
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "daemon"
}

task stopQuoter(type: Exec, dependsOn: releaseQuoter) {
    environment "RELEASE_COOKIE", "intellij_elixir"
    environment "RELEASE_DISTRIBUTION", "name"
    environment "RELEASE_NAME", "intellij_elixir@127.0.0.1"
    executable quoterExe
    args "stop"
}

runIde {
    jvmArgs "-Didea.ProcessCanceledException=disabled"
    maxHeapSize = "7g"
}

test {
    dependsOn runQuoter
    finalizedBy stopQuoter
}

apply plugin: 'idea'
idea {
    project {
        jdkName = javaVersion
        languageLevel = javaVersion
    }
    module {
        generatedSourceDirs += file('gen')
    }
}
